{"version":3,"sources":["animations/Demo.js","PathfindingVisualizer/Node/Node.jsx","PathfindingVisualizer/PathfindingVisualizer.jsx","PathfindingVisualizer/NavBar.jsx","algorithms/dijkstra.js","algorithms/astar.js","mazeAlgorithms/recursiveDivision.js","mazeAlgorithms/staircaseMaze.js","mazeAlgorithms/maze3.js","mazeAlgorithms/maze4.js","App.js","animations/NotFound.js","serviceWorker.js","index.js"],"names":["Demo","className","id","activeClassName","to","style","backgroundColor","title","React","Component","Node","this","props","row","col","isStart","isFinish","isWall","onMouseUp","onMouseEnter","onMouseDown","isBomb","extraClassName","PathfindingVisualizer","grid","mouseIsPressed","map","rowIdx","key","node","nodeIdx","isVisited","handleMouseUp","handleMouseDown","handleMouseEnter","NavBar","Fragment","href","role","aria-label","type","onClick","visualizeRecursiveDivision","visualizeStaircase","visualizeMazeThree","visualizeMazeFour","genRandomWalls","visualizeDijkstra","visualizeAstar","clearBoard","clearPath","addBomb","removeBomb","dijkstra","startNode","finishNode","distance","Infinity","previousNode","setAllDistanceToInfinity","visitedNodesInOrder","unvisitedNodes","nodes","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","updateUnvisitedNeighbors","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","sort","nodeA","nodeB","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift","astar","a","Math","abs","b","h","sqrt","pow","heuristicDistance","totalDistance","addHeuristicDistanceToNodes","sortNodesByTotalDistance","getNodesInShortestPathOrderAstar","recursiveDivision","NUMBER_OF_ROWS","NUMBER_OF_COLS","x","w","i","floor","staircaseMaze","mazeThree","q","j","mazeFour","y","centerText","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","BOMB_NODE_ROW","BOMB_NODE_COL","bombNode","status","draggingStart","draggingFinish","draggingBomb","App","state","newGrid","getNewGridWithStartNodeToggled","setState","getNewGridWithFinishNodeToggled","getNewGridWithBombNodeToggled","getNewGridWithWallToggled","slice","newNode","document","getElementById","classList","remove","getInitialGrid","currentRow","createNode","animateDijsktra","bomb","nodesInShortestPathOrderWithBomb","setTimeout","animateShortestPath","removeArrowClass","element","determineImage","arrowForSecondLastNode","undefined","backgroundImage","reEnableButtons","enableGrid","animateDijsktraWithBomb","newVisitedNodesInOrder","newNodesInShortestPathOrder0","newStart","newFinish","nodesInShortestPathOrder1","disableButtons","disableGrid","bombIsPresent","finish","bombNode1","animateAstar","animateAstarWithBomb","start","disabled","genRandomNumber","random","resetNodeWalls","numberOfPlainNodes","k","pointerEvents","buttons","getElementsByClassName","navBarHeight","clientHeight","gridHeight","window","innerHeight","gridWidth","clientWidth","getWindowSize","myStyle","color","padding","fontFamily","textContent","display","marginBottom","fontStyle","float","NotFound","Boolean","location","hostname","match","routing","exact","path","component","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"mZA8IeA,G,uLAnIX,OACE,6BACE,4BAAQC,UAAU,aAAaC,GAAG,uBAChC,kBAAC,IAAD,CAASC,gBAAgB,SAASC,GAAG,KAArC,sBAIF,yBAAKH,UAAU,aACb,yBAAKC,GAAG,UACN,wBAAIG,MAAO,CAAEC,gBAAiB,cAA9B,yBAEE,2BAAOL,UAAU,cAAjB,iCAEF,gCACEA,UAAU,sDACVI,MAAO,CAAEC,gBAAiB,eAE1B,uBAAGL,UAAU,QAAb,4DAGA,4BAAQA,UAAU,qBAChB,0BAAMM,MAAM,gBAAZ,gBAGJ,wBAAIN,UAAU,oBACX,IACD,kBAAC,IAAD,CAASE,gBAAgB,SAASC,GAAG,YAArC,cAEW,IAJb,+DAQF,yBAAKF,GAAG,iBACN,yBAAKA,GAAG,kBACN,yBAAKA,GAAG,iBAAR,KADF,cAGA,yBAAKA,GAAG,kBACN,yBAAKA,GAAG,kBAAR,KADF,mBAGA,yBAAKA,GAAG,kBACN,yBAAKA,GAAG,qBAAR,MAEF,yBAAKA,GAAG,kBACN,yBAAKA,GAAG,qBAAR,KADF,kBAGA,yBAAKA,GAAG,kBACN,yBAAKA,GAAG,kBAAR,KADF,eAGA,yBAAKA,GAAG,kBACN,yBAAKA,GAAG,mBAAR,KADF,gBAGA,yBAAKA,GAAG,kBACN,yBAAKA,GAAG,iBAAR,KADF,cAGA,yBAAKA,GAAG,kBACN,yBAAKA,GAAG,qBAAR,KADF,uBAIF,yBAAKA,GAAG,aACN,wBAAID,UAAU,cACZ,wBAAIA,UAAU,mBACZ,4BACG,IACD,gCACG,IADH,kJAOF,yBAAKC,GAAG,uBAEV,wBAAID,UAAU,mBACZ,4BACE,0EAEF,yBAAKC,GAAG,0BAEV,wBAAID,UAAU,mBACZ,4BACE,gJAKF,yBAAKC,GAAG,sBAEV,wBAAID,UAAU,mBACZ,4BACE,yFAIF,yBAAKC,GAAG,0BAEV,wBAAID,UAAU,mBACZ,4BACE,6JAMF,yBAAKC,GAAG,2BAEV,wBAAID,UAAU,mBACZ,4BACE,sHAKF,yBAAKC,GAAG,iBAEV,wBAAID,UAAU,mBACZ,4BACE,qEAEF,yBAAKC,GAAG,cAEV,wBAAID,UAAU,mBACZ,6BACA,yBAAKC,GAAG,sB,GA5HLM,IAAMC,YC4BVC,G,MAlCf,iLACY,IAAD,EAWHC,KAAKC,MATPC,EAFK,EAELA,IACAC,EAHK,EAGLA,IACAC,EAJK,EAILA,QACAC,EALK,EAKLA,SACAC,EANK,EAMLA,OACAC,EAPK,EAOLA,UACAC,EARK,EAQLA,aACAC,EATK,EASLA,YACAC,EAVK,EAULA,OAEIC,EAAiBN,EACnB,cACAD,EACA,aACAE,EACA,YACAI,EACA,YACA,GACJ,OACE,yBACEnB,GAAE,eAAUW,EAAV,YAAiBC,GACnBb,UAAS,eAAUqB,GACnBF,YAAa,kBAAMA,EAAYP,EAAKC,IACpCK,aAAc,kBAAMA,EAAaN,EAAKC,IACtCI,UAAW,kBAAMA,EAAUL,EAAKC,UA5BxC,GAA0BL,cCqDXc,G,MAnDf,iLACY,IAAD,SAC0BZ,KAAKC,MAA9BY,EADD,EACCA,KAAMC,EADP,EACOA,eACd,OACE,6BACE,yBAAKxB,UAAU,QACZuB,EAAKE,KAAI,SAACb,EAAKc,GACd,OACE,yBAAKC,IAAKD,EAAQ1B,UAAU,OACzBY,EAAIa,KAAI,SAACG,EAAMC,GAAa,IAEzBjB,EAOEgB,EAPFhB,IACAC,EAMEe,EANFf,IACAC,EAKEc,EALFd,QACAC,EAIEa,EAJFb,SACAC,EAGEY,EAHFZ,OACAc,EAEEF,EAFFE,UACAV,EACEQ,EADFR,OAEF,OACE,kBAAC,EAAD,CACEA,OAAQA,EACRU,UAAWA,EACXH,IAAKE,EACLhB,IAAKA,EACLD,IAAKA,EACLY,eAAgBA,EAChBR,OAAQA,EACRF,QAASA,EACTC,SAAUA,EACVE,UAAW,SAACL,EAAKC,GAAN,OACT,EAAKF,MAAMoB,cAAcnB,EAAKC,IAEhCM,YAAa,SAACP,EAAKC,GAAN,OACX,EAAKF,MAAMqB,gBAAgBpB,EAAKC,IAElCK,aAAc,SAACN,EAAKC,GAAN,OACZ,EAAKF,MAAMsB,iBAAiBrB,EAAKC,mBArCzD,GAA2CL,cCiI5B0B,E,iLApIH,IAAD,OACP,OACE,kBAAC,IAAMC,SAAP,KACE,yBAAKnC,UAAU,0CACb,uBAAGoC,KAAK,KACN,wBAAIpC,UAAU,cAAd,4BAEF,yBACEA,UAAU,cACVqC,KAAK,UACLC,aAAW,8BAEX,yBACEtC,UAAU,iBACVqC,KAAK,QACLC,aAAW,eAEX,4BACEC,KAAK,SACLvC,UAAU,oBAEVM,MAAM,6BAJR,SAQA,4BACEiC,KAAK,SACLvC,UAAU,qBACVM,MAAM,0BACNkC,QAAS,kBAAM,EAAK7B,MAAM8B,+BAJ5B,MAQA,4BACEF,KAAK,SACLvC,UAAU,oBACVM,MAAM,wBACNkC,QAAS,kBAAM,EAAK7B,MAAM+B,uBAJ5B,MAQA,4BACEH,KAAK,SACLvC,UAAU,qBACVM,MAAM,SACNkC,QAAS,kBAAM,EAAK7B,MAAMgC,uBAJ5B,MAQA,4BACEJ,KAAK,SACLvC,UAAU,oBACVM,MAAM,qCACNkC,QAAS,kBAAM,EAAK7B,MAAMiC,sBAJ5B,MAQA,4BACEL,KAAK,SACLvC,UAAU,qBACVM,MAAM,wBACNkC,QAAS,WACP,EAAK7B,MAAMkC,mBALf,QAYJ,6BACE,4BACE7C,UAAU,oCACVM,MAAM,+BACNkC,QAAS,WACP,EAAK7B,MAAMmC,sBAJf,sBASA,4BACE9C,UAAU,oCACVM,MAAM,yBACNkC,QAAS,WACP,EAAK7B,MAAMoC,mBAJf,mBASA,4BACE/C,UAAU,qCACVM,MAAM,qBACNkC,QAAS,kBAAM,EAAK7B,MAAMqC,eAH5B,eAOA,4BACEhD,UAAU,qCACVM,MAAM,sBACNkC,QAAS,kBAAM,EAAK7B,MAAMsC,cAH5B,cAOA,4BACEjD,UAAU,qCACVC,GAAG,kBACHK,MAAM,iBACNkC,QAAS,kBAAM,EAAK7B,MAAMuC,YAJ5B,YAQA,4BACElD,UAAU,qCACVM,MAAM,mBACNkC,QAAS,kBAAM,EAAK7B,MAAMwC,eAH5B,eAQA,4BACEnD,UAAU,qCACVM,MAAM,wBACNkC,QAAS,kBAAM,EAAK7B,MAAMkC,mBAH5B,gC,GAvHSrC,a,MCId,SAAS4C,EAAS7B,EAAM8B,EAAWC,IAqB1C,SAAkC/B,GAAO,IAAD,uBACtC,YAAkBA,EAAlB,+CAAwB,CAAC,IAAdX,EAAa,+BACtB,YAAmBA,EAAnB,+CAAwB,CAAC,IAAdgB,EAAa,QACtBA,EAAK2B,SAAWC,IAChB5B,EAAKE,WAAY,EACjBF,EAAK6B,aAAe,MAJA,oFADc,mFApBtCC,CAAyBnC,GACzB,IAAMoC,EAAsB,GAC5BN,EAAUE,SAAW,EAErB,IADA,IAAMK,EA0DR,SAAqBrC,GACnB,IAAMsC,EAAQ,GADW,uBAEzB,YAAkBtC,EAAlB,+CAAwB,CAAC,IAAdX,EAAa,+BACtB,YAAmBA,EAAnB,+CAAwB,CAAC,IAAdgB,EAAa,QACtBiC,EAAMC,KAAKlC,IAFS,oFAFC,kFAOzB,OAAOiC,EAjEgBE,CAAYxC,GAC5BqC,EAAeI,QAAQ,CAC5BC,EAAoBL,GAGpB,IAAMM,EAAcN,EAAeO,QAEnC,IAAID,EAAYlD,OAAhB,CAGA,GAAIkD,EAAYX,WAAaC,IAAU,OAAOG,EAG9C,GAFAO,EAAYpC,WAAY,EACxB6B,EAAoBG,KAAKI,GACrBA,IAAgBZ,EAAY,OAAOK,EACvCS,EAAyBF,EAAa3C,KAY1C,SAAS6C,EAAyBxC,EAAML,GACtC,IAAM8C,EAMR,SAA+BzC,EAAML,GACnC,IAAM+C,EAAY,GACV1D,EAAagB,EAAbhB,IAAKC,EAAQe,EAARf,IAETD,EAAM,GAAG0D,EAAUR,KAAKvC,EAAKX,EAAM,GAAGC,IAEtCD,EAAMW,EAAKyC,OAAS,GAAGM,EAAUR,KAAKvC,EAAKX,EAAM,GAAGC,IAEpDA,EAAM,GAAGyD,EAAUR,KAAKvC,EAAKX,GAAKC,EAAM,IAExCA,EAAMU,EAAK,GAAGyC,OAAS,GAAGM,EAAUR,KAAKvC,EAAKX,GAAKC,EAAM,IAS7D,OAAOyD,EAAUC,QAAO,SAAAC,GAAQ,OAAKA,EAAS1C,aAzBnB2C,CAAsB7C,EAAML,GADX,uBAE5C,YAAqB8C,EAArB,+CAAyC,CAAC,IAAjCG,EAAgC,QACvCA,EAASjB,SAAW3B,EAAK2B,SAAW,EACpCiB,EAASf,aAAe7B,GAJkB,mFA6B9C,SAASqC,EAAoBL,GAC3BA,EAAec,MAAK,SAACC,EAAOC,GAAR,OAAkBD,EAAMpB,SAAWqB,EAAMrB,YAcxD,SAASsB,EAA4BvB,GAI1C,IAHA,IAAMwB,EAA2B,GAC7BC,EAAczB,EAEK,OAAhByB,GACLD,EAAyBE,QAAQD,GACjCA,EAAcA,EAAYtB,aAE5B,OAAOqB,ECpFF,SAASG,EAAM1D,EAAM8B,EAAWC,IAmBvC,SAAkC/B,GAAO,IAAD,uBACtC,YAAkBA,EAAlB,+CAAwB,CAAC,IAAdX,EAAa,+BACtB,YAAmBA,EAAnB,+CAAwB,CAAC,IAAdgB,EAAa,QACtBA,EAAK2B,SAAWC,IAChB5B,EAAKE,WAAY,EACjBF,EAAK6B,aAAe,MAJA,oFADc,mFAlBtCC,CAAyBnC,GAEzB,IAAMoC,EAAsB,GAC5BN,EAAUE,SAAW,EA6DvB,SAAqChC,EAAM8B,EAAWC,GAAa,IAAD,uBAChE,YAAkB/B,EAAlB,+CAAwB,CAAC,IAAdX,EAAa,+BACtB,YAAmBA,EAAnB,+CAAwB,CAAC,IAAdgB,EAAa,QAChBsD,EAAIC,KAAKC,IAAI9B,EAAWzC,IAAMe,EAAKf,KACnCwE,EAAIF,KAAKC,IAAI9B,EAAW1C,IAAMgB,EAAKhB,KACnC0E,EAAIH,KAAKI,KAAKJ,KAAKK,IAAIN,EAAG,GAAKC,KAAKK,IAAIH,EAAG,IAGjDzD,EAAK6D,kBAAoBH,EAAI,IAE7B1D,EAAK8D,cAAgB9D,EAAK2B,SAAW3B,EAAK6D,mBATtB,oFADwC,mFA5DhEE,CAA4BpE,EAAM8B,EAAWC,GAE7C,IADA,IAAMM,EA0ER,SAAqBrC,GACnB,IAAMsC,EAAQ,GADW,uBAEzB,YAAkBtC,EAAlB,+CAAwB,CAAC,IAAdX,EAAa,+BACtB,YAAmBA,EAAnB,+CAAwB,CAAC,IAAdgB,EAAa,QACtBiC,EAAMC,KAAKlC,IAFS,oFAFC,kFAOzB,OAAOiC,EAjFgBE,CAAYxC,GAC5BqC,EAAeI,QAAQ,CAC5B4B,EAAyBhC,GACzB,IAAMM,EAAcN,EAAeO,QACnC,IAAID,EAAYlD,OAAhB,CACA,GAAIkD,EAAYX,WAAaC,IAAU,OAAOG,EAI9C,GAFAO,EAAYpC,WAAY,EACxB6B,EAAoBG,KAAKI,GACrBA,IAAgBZ,EAAY,OAAOK,EACvCS,EAAyBF,EAAa3C,KAa1C,SAAS6C,EAAyBxC,EAAML,GACtC,IAAM8C,EASR,SAA+BzC,EAAML,GACnC,IAAM+C,EAAY,GACV1D,EAAagB,EAAbhB,IAAKC,EAAQe,EAARf,IACTD,EAAM,GAAG0D,EAAUR,KAAKvC,EAAKX,EAAM,GAAGC,IACtCD,EAAMW,EAAKyC,OAAS,GAAGM,EAAUR,KAAKvC,EAAKX,EAAM,GAAGC,IACpDA,EAAM,GAAGyD,EAAUR,KAAKvC,EAAKX,GAAKC,EAAM,IACxCA,EAAMU,EAAK,GAAGyC,OAAS,GAAGM,EAAUR,KAAKvC,EAAKX,GAAKC,EAAM,IAa7D,OAAOyD,EAAUC,QAAO,SAAAC,GAAQ,OAAKA,EAAS1C,aA5BnB2C,CAAsB7C,EAAML,GADX,uBAG5C,YAAqB8C,EAArB,+CAAyC,CAAC,IAAjCG,EAAgC,QACvCA,EAASjB,SAAW3B,EAAK2B,SAAW,EACpCiB,EAASkB,cAAgB9D,EAAK2B,SAAW,EAAIiB,EAASiB,kBAEtDjB,EAASf,aAAe7B,GAPkB,mFA+B9C,SAASgE,EAAyBhC,GAChCA,EAAec,MACb,SAACC,EAAOC,GAAR,OAAkBD,EAAMe,cAAgBd,EAAMc,iBA4B3C,SAASG,EAAiCvC,GAI/C,IAHA,IAAMwB,EAA2B,GAC7BC,EAAczB,EAEK,OAAhByB,GACLD,EAAyBE,QAAQD,GACjCA,EAAcA,EAAYtB,aAE5B,OAAOqB,ECpGF,SAASgB,EAAkBvE,EAAMwE,EAAgBC,GAMtD,IALA,IAAInC,EAAQ,GACRoC,EAAI,EACFrF,EAAMmF,EACRG,EAAI,GAEDA,GAAG,CAER,IAAK,IAAIC,EAAIvF,EAAM,EAAGuF,GAAK,EAAGA,IACxBA,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,MAC7BuF,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,MAEjCiD,EAAMC,KAAKvC,EAAK4E,GAAGF,IAErBA,GAAK,EAEL,IAAK,IAAIE,EAAI,EAAGA,GAAK,EAAGA,IACtBtC,EAAMC,KAAKvC,EAAK,GAAG0E,IACnBA,GAAK,EAGP,IAAK,IAAIE,EAAI,EAAGA,EAAIvF,EAAM,EAAGuF,IACvBA,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,MAC7BuF,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,IACjCiD,EAAMC,KAAKvC,EAAK4E,GAAGF,IAGrB,IAAK,IAAIE,EAAI,EAAGA,GAAK,EAAGA,IACtBtC,EAAMC,KAAKvC,EAAKX,EAAM,GAAGqF,IACzBA,GAAK,EAEPC,GAAK,EAEP,OAAOrC,EClCF,SAASwC,EAAc9E,EAAMwE,EAAgBC,GAKlD,IAJA,IAAMpF,EAAMmF,EACRlC,EAAQ,GACRoC,EAAI,EACJC,EAAI,GACDA,GAAG,CACR,IAAK,IAAIC,EAAIvF,EAAM,EAAGuF,GAAK,EAAGA,IACxBA,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,IAC7BuF,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,OAEjCiD,EAAMC,KAAKvC,EAAK4E,GAAGF,IACnBA,GAAK,GAEP,IAAK,IAAIE,EAAI,EAAGA,EAAIvF,EAAM,EAAGuF,IACvBA,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,IAC7BuF,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,OAEjCiD,EAAMC,KAAKvC,EAAK4E,GAAGF,IACnBA,GAAK,GAEPC,GAAK,EAEP,OAAOrC,ECtBF,SAASyC,EAAU/E,EAAMwE,EAAgBC,GAI9C,IAHA,IAAInC,EAAQ,GACNjD,EAAMmF,EACNlF,EAAMmF,EACHG,EAAIhB,KAAKiB,MAAMxF,EAAM,KAAMuF,EAAIhB,KAAKiB,MAAMxF,EAAM,KAAMuF,IAC7DtC,EAAMC,KAAKvC,EAAK4E,GAAGhB,KAAKiB,MAAMvF,EAAM,KAItC,IAAK,IAAIsF,EAAI,EAAGA,EAAItF,EAAM,EAAGsF,IAC3BtC,EAAMC,KAAKvC,EAAK,GAAG4E,IAGrB,IAAK,IAAIA,EAAI,EAAGA,EAAItF,EAAM,EAAGsF,IAC3BtC,EAAMC,KAAKvC,EAAKX,EAAM,GAAGuF,IAG3B,IAAK,IAAIA,EAAI,EAAGA,EAAIvF,EAAM,EAAGuF,IAC3BtC,EAAMC,KAAKvC,EAAK4E,GAAG,IAGrB,IAAK,IAAIA,EAAI,EAAGA,EAAIvF,EAAM,EAAGuF,IAC3BtC,EAAMC,KAAKvC,EAAK4E,GAAGtF,EAAM,IAI3B,IADA,IAAI0F,EAAI,EACCC,EAAI,EAAGA,EAAI,GAAIA,IAAK,CAG3B,IAAK,IAAIL,EAAI,EAAGA,EAAIhB,KAAKiB,MAAMxF,EAAM,GAAIuF,IACnCA,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,MAC7BuF,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,MACjCiD,EAAMC,KAAKvC,EAAK4E,GAAGI,IAGrB,IAAK,IAAIJ,EAAIvF,EAAM,EAAGuF,EAAIhB,KAAKiB,MAAMxF,EAAM,KAAMuF,IAC3CA,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,MAC7BuF,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,MACjCiD,EAAMC,KAAKvC,EAAK4E,GAAGI,IAGrBA,GAAK,EACL,IAAK,IAAIJ,EAAI,EAAGA,EAAIhB,KAAKiB,MAAMxF,EAAM,GAAIuF,IACnCA,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,MAC7BuF,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,MACjCiD,EAAMC,KAAKvC,EAAK4E,GAAGI,IAGrB,IAAK,IAAIJ,EAAIvF,EAAM,EAAGuF,EAAIhB,KAAKiB,MAAMxF,EAAM,GAAIuF,IACzCA,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,MAC7BuF,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,MACjCiD,EAAMC,KAAKvC,EAAK4E,GAAGI,IAGvB,OAAO1C,ECtDF,SAAS4C,EAASlF,EAAMwE,EAAgBC,GAI7C,IAHA,IAAInC,EAAQ,GACNjD,EAAMmF,EACNlF,EAAMmF,EACHG,EAAIhB,KAAKiB,MAAMxF,EAAM,KAAMuF,EAAIhB,KAAKiB,MAAMxF,EAAM,KAAMuF,IAC7DtC,EAAMC,KAAKvC,EAAK4E,GAAGhB,KAAKiB,MAAMvF,EAAM,KAItC,IAAK,IAAIsF,EAAI,EAAGA,EAAItF,EAAKsF,IACvBtC,EAAMC,KAAKvC,EAAK,GAAG4E,IAGrB,IAAK,IAAIA,EAAI,EAAGA,EAAItF,EAAKsF,IACvBtC,EAAMC,KAAKvC,EAAKX,EAAM,GAAGuF,IAG3B,IAAK,IAAIA,EAAI,EAAGA,EAAIvF,EAAM,EAAGuF,IAC3BtC,EAAMC,KAAKvC,EAAK4E,GAAG,IAGrB,IAAK,IAAIA,EAAI,EAAGA,EAAIvF,EAAM,EAAGuF,IAC3BtC,EAAMC,KAAKvC,EAAK4E,GAAGtF,EAAM,IAK3B,IAHA,IAAIoF,EAAI,EACJS,EAAI,EACJR,EAAI,GACDA,GAAG,CACR,IAAK,IAAIC,EAAIvF,EAAM,EAAGuF,GAAK,EAAGA,IACxBA,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,IAC7BuF,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,OAEjCiD,EAAMC,KAAKvC,EAAK4E,GAAGF,IACnBA,GAAK,GAEP,IAAK,IAAIE,EAAI,EAAGA,GAAKvF,EAAM,EAAGuF,IACxBA,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,IAC7BuF,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,OAEjCiD,EAAMC,KAAKvC,EAAK4E,GAAGO,IACnBA,GAAK,GAEP,IAAK,IAAIP,EAAI,EAAGA,EAAIvF,EAAM,EAAGuF,IACvBA,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,IAC7BuF,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,OAEjCiD,EAAMC,KAAKvC,EAAK4E,GAAGF,IACnBA,GAAK,GAEP,IAAK,IAAIE,EAAIvF,EAAM,EAAGuF,EAAI,EAAGA,IACvBA,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,IAC7BuF,IAAMhB,KAAKiB,OAAOxF,EAAM,GAAK,OAEjCiD,EAAMC,KAAKvC,EAAK4E,GAAGO,IACnBA,GAAK,GAEPR,GAAK,EAEP,OAAOrC,ECxCT,IAAI8C,EACF,2KACEZ,EAAiB,GACnBC,EAAiB,GACfY,EAAiB,GACnBC,EAAiB,GACjBC,EAAkB,GAClBC,EAAkB,GAClBC,EAAgB,GAChBC,EAAgB,GACd5D,EAAY,CACdzC,IAAKgG,EACL/F,IAAKgG,GAEHvD,EAAa,CACf1C,IAAKkG,EACLjG,IAAKkG,GAEHG,EAAW,CACbtG,IAAKoG,EACLnG,IAAKoG,EACLE,QAAQ,GAENC,GAAgB,EAClBC,GAAiB,EACjBC,GAAe,EAq2BFC,EAp2Bf,2MACEC,MAAQ,CACNjG,KAAM,GACNC,gBAAgB,GAHpB,EA8BEQ,gBAAkB,SAACpB,EAAKC,GACtB,EAAKoC,YACL,IAAMrB,EACChB,EADDgB,EAECf,EAEP,GAAIe,IAAayB,EAAUzC,KAAOgB,IAAayB,EAAUxC,IAAK,CAC5D,IAAM4G,EAAU,EAAKC,+BACnB,EAAKF,MAAMjG,KACXX,EACAC,GAIF,EAAK8G,SAAS,CAAEpG,KAAMkG,EAASjG,gBAAgB,IAC/C4F,GAAgB,OACX,GAAIxF,IAAa0B,EAAW1C,KAAOgB,IAAa0B,EAAWzC,IAAK,CACrE,IAAM4G,EAAU,EAAKG,gCACnB,EAAKJ,MAAMjG,KACXX,EACAC,GAEF,EAAK8G,SAAS,CAAEpG,KAAMkG,EAASjG,gBAAgB,IAC/C6F,GAAiB,OACZ,GACLzF,IAAasF,EAAStG,KACtBgB,IAAasF,EAASrG,KACtBqG,EAASC,OACT,CACA,IAAMM,EAAU,EAAKI,8BACnB,EAAKL,MAAMjG,KACXX,EACAC,GAEF,EAAK8G,SAAS,CAAEpG,KAAMkG,EAASjG,gBAAgB,IAC/C8F,GAAe,MACV,CACL,IAAMG,EAAU,EAAKK,0BAA0B,EAAKN,MAAMjG,KAAMX,EAAKC,GACrE,EAAK8G,SAAS,CAAEpG,KAAMkG,EAASjG,gBAAgB,MApErD,EA4EES,iBAAmB,SAACrB,EAAKC,GACvB,GAAK,EAAK2G,MAAMhG,kBAKXZ,IAAQsG,EAAStG,KAAOC,IAAQqG,EAASrG,KACzCD,IAAQyC,EAAUzC,KAAOC,IAAQwC,EAAUxC,KAC3CD,IAAQ0C,EAAW1C,KAAOC,IAAQyC,EAAWzC,KAEhD,CACA,IAAM4G,EAAU,EAAKK,0BAA0B,EAAKN,MAAMjG,KAAMX,EAAKC,GACrE,EAAK8G,SAAS,CAAEpG,KAAMkG,MAxF5B,EA4FE1F,cAAgB,SAACnB,EAAKC,GACpB,GAAIuG,EAAe,CACjB,IAAMK,EAAU,EAAKC,+BACnB,EAAKF,MAAMjG,KACXX,EACAC,GAEF,EAAK8G,SAAS,CAAEpG,KAAMkG,SACjB,GAAIJ,EAAgB,CACzB,IAAMI,EAAU,EAAKG,gCACnB,EAAKJ,MAAMjG,KACXX,EACAC,GAEF,EAAK8G,SAAS,CAAEpG,KAAMkG,SACjB,GAAIH,EAAc,CACvB,IAAMG,EAAU,EAAKI,8BACnB,EAAKL,MAAMjG,KACXX,EACAC,GAEF,EAAK8G,SAAS,CAAEpG,KAAMkG,IAExB,EAAKE,SAAS,CAAEnG,gBAAgB,IAEhC4F,GAAgB,EAChBC,GAAiB,EACjBC,GAAe,GAvHnB,EAyHEO,8BAAgC,SAACtG,EAAMX,EAAKC,GAC1CqG,EAAStG,IAAMA,EACfsG,EAASrG,IAAMA,EACf,IAAM4G,EAAUlG,EAAKwG,QACfnG,EAAO6F,EAAQ7G,GAAKC,GACpBmH,EAAO,eACRpG,EADQ,CAEXR,QAASQ,EAAKR,OACdJ,QAAQ,IAaV,OAXgBiH,SAASC,eAAT,eACNhB,EAAStG,IADH,YACUsG,EAASrG,MAG3BsH,UAAUC,OAAO,aACzBX,EAAQ7G,GAAKC,GAAOmH,EAMbP,GA9IX,EAgJEC,+BAAiC,SAACnG,EAAMX,EAAKC,GAC3C,IAAM4G,EAAUlG,EAAKwG,QACfnG,EAAO6F,EAAQ7G,GAAKC,GAC1BwC,EAAUzC,IAAMA,EAChByC,EAAUxC,IAAMA,EAChB,IAAMmH,EAAO,eACRpG,EADQ,CAEXd,SAAUc,EAAKd,QAKfE,QAAQ,IAKV,OADAyG,EAAQ7G,GAAKC,GAAOmH,EACbP,GAjKX,EAmKEG,gCAAkC,SAACrG,EAAMX,EAAKC,GAC5C,IAAM4G,EAAUlG,EAAKwG,QACrBzE,EAAW1C,IAAMA,EACjB0C,EAAWzC,IAAMA,EACjB,IAAMe,EAAO6F,EAAQ7G,GAAKC,GACpBmH,EAAO,eACRpG,EADQ,CAEXb,UAAWa,EAAKb,SAChBC,QAAQ,IAGV,OADAyG,EAAQ7G,GAAKC,GAAOmH,EACbP,GA9KX,EAiLEK,0BAA4B,SAACvG,EAAMX,EAAKC,GAEtC,IAAM4G,EAAUlG,EAAKwG,QACfnG,EAAO6F,EAAQ7G,GAAKC,GAEpBmH,EAAO,eACRpG,EADQ,CAEXZ,QAASY,EAAKZ,SAGhB,OADAyG,EAAQ7G,GAAKC,GAAOmH,EACbP,GA3LX,EA6LEY,eAAiB,WAEf,IADA,IAAI9G,EAAO,GACFX,EAAM,EAAGA,EAAMmF,EAAgBnF,IAAO,CAE7C,IADA,IAAI0H,EAAa,GACRzH,EAAM,EAAGA,EAAMmF,EAAgBnF,IACtCyH,EAAWxE,KAAK,EAAKyE,WAAW1H,EAAKD,IAEvCW,EAAKuC,KAAKwE,GAEZ,OAAO/G,GAtMX,EAwMEgH,WAAa,SAAC1H,EAAKD,GACjB,MAAO,CACLkB,WAAW,EACXjB,MACAD,MACAE,QAASF,IAAQgG,GAAkB/F,IAAQgG,EAC3C9F,SAAUH,IAAQkG,GAAmBjG,IAAQkG,EAC7CxD,SAAUC,IACVxC,QAAQ,EACRyC,aAAc,KACdrC,QAAQ,IAlNd,EAsNEoH,gBAAkB,SAChB7E,EACAmB,EACA2D,EACAC,GAEA,IADI,IAAD,WACMvC,GACP,GAAIA,IAAMxC,EAAoBK,OAW5B,OAVA2E,YAAW,WACJF,EAKH,EAAKG,oBAAoBF,GAHzB,EAAKE,oBAAoB9D,KAM1B,GAAKqB,GACF,CAAN,UAEFwC,YAAW,WACT,IAAM/G,EAAO+B,EAAoBwC,GAE3BvE,EAAKd,SAAWc,EAAKb,UAAYa,EAAKR,SAC1C6G,SAASC,eAAT,eAAgCtG,EAAKhB,IAArC,YAA4CgB,EAAKf,MAAOb,UACtD,uBAEH,GAAKmG,IArBDA,EAAI,EAAGA,GAAKxC,EAAoBK,OAAQmC,IAAK,CAAC,IAAD,IAA7CA,GAA6C,oCA5N1D,EAqPE0C,iBAAmB,WAAO,IAChBtH,EAAS,EAAKiG,MAAdjG,KADe,uBAEvB,YAAkBA,EAAlB,+CAAwB,CAAC,IAAdX,EAAa,+BACtB,YAAmBA,EAAnB,+CAAwB,CAAC,IAAdgB,EAAa,QAChBkH,EAAUb,SAASC,eAAT,eAAgCtG,EAAKhB,IAArC,YAA4CgB,EAAKf,MACjEiI,EAAQX,UAAUC,OAAO,oBACzBU,EAAQX,UAAUC,OAAO,mBACzBU,EAAQX,UAAUC,OAAO,iBACzBU,EAAQX,UAAUC,OAAO,oBANL,oFAFD,oFArP3B,EAiQEW,eAAiB,SAAChE,EAAatB,GAC7B,IAAMqF,EAAUb,SAASC,eAAT,eACNnD,EAAYnE,IADN,YACamE,EAAYlE,MAErCkE,EAAYlE,IAAM4C,EAAa5C,IAEjCiI,EAAQ9I,UAAY,2CACX+E,EAAYnE,IAAM6C,EAAa7C,IAExCkI,EAAQ9I,UAAY,wCACX+E,EAAYlE,IAAM4C,EAAa5C,IAExCiI,EAAQ9I,UAAY,0CACX+E,EAAYnE,IAAM6C,EAAa7C,MAExCkI,EAAQ9I,UAAY,4CAhR1B,EAoREgJ,uBAAyB,SAACpH,EAAM6B,GAE9B,QAAqBwF,IAAjBxF,QACSwF,IAATrH,EAAJ,CACA,IAAMkH,EAAUb,SAASC,eAAT,eACNzE,EAAa7C,IADP,YACc6C,EAAa5C,MAEvCe,EAAKf,IAAM4C,EAAa5C,IAE1BiI,EAAQ9I,UAAY,2CACX4B,EAAKhB,IAAM6C,EAAa7C,IAEjCkI,EAAQ9I,UAAY,0CACX4B,EAAKhB,IAAM6C,EAAa7C,IAEjCkI,EAAQ9I,UAAY,wCACX4B,EAAKf,IAAM4C,EAAa5C,MAEjCiI,EAAQ9I,UAAY,6CAtS1B,EAySE4I,oBAAsB,SAAA9D,GACpB,IADiD,IAAD,WACvCqB,GACPwC,YAAW,WACT,IAAM/G,EAAOkD,EAAyBqB,GAChC1C,EAAeqB,EAAyBqB,EAAI,GAC5CvE,EAAKd,SAAWc,EAAKb,UAAYa,EAAKR,SAC1C6G,SAASC,eAAT,eAAgCtG,EAAKhB,IAArC,YAA4CgB,EAAKf,MAAOb,UACtD,0BAEF,EAAK+I,eAAenH,EAAM6B,GAKtBA,EAAa3C,SACb2C,EAAa1C,UACb0C,EAAarC,SAGf6G,SAASC,eAAT,eACUzE,EAAa7C,IADvB,YAC8B6C,EAAa5C,MACzCT,MAAM8I,gBAAkB,SAI1BtH,EAAKR,QAEP,EAAK4H,uBAAuBpH,EAAM6B,GAGhC7B,EAAKb,UAEP,EAAKiI,uBAAuBpH,EAAM6B,GAEhC0C,IAAMrB,EAAyBd,OAAS,IAC1C,EAAKmF,kBACL,EAAKC,gBAEN,GAAKjD,IArCDA,EAAI,EAAGA,EAAIrB,EAAyBd,OAAQmC,IAAM,EAAlDA,IA1Sb,EAmVEkD,wBAA0B,SACxBC,EACAC,EACAC,EACAC,GAEA,IADI,IAAD,WACMtD,GACP,GAAIA,IAAMmD,EAAuBtF,OAkB/B,OAjBA2E,YAAW,WAAO,IAEVhF,EAAsBP,EADX,EAAKoE,MAAdjG,KACmCiI,EAAUC,GAC/CC,EAA4B7E,EAChC4E,GAEI3E,EAAwB,sBACzByE,GADyB,YAEzBG,IAEL,EAAKlB,gBACH7E,EACA+F,GACA,EACA5E,KAED,GAAKqB,GACF,CAAN,UAEFwC,YAAW,WACT,IAAM/G,EAAO0H,EAAuBnD,GAE9BvE,EAAKd,SAAWc,EAAKb,UAAYa,EAAKR,SAC1C6G,SAASC,eAAT,eAAgCtG,EAAKhB,IAArC,YAA4CgB,EAAKf,MAAOb,UACtD,4BAEH,GAAKmG,IA5BDA,EAAI,EAAGA,GAAKmD,EAAuBtF,OAAQmC,IAAK,CAAC,IAAD,IAAhDA,GAAgD,oCAzV7D,EAyXErD,kBAAoB,WAClB6D,EACE,wMAGF,EAAK1D,YACL,EAAK0G,iBACL,EAAKC,cAPmB,IAQhBrI,EAAS,EAAKiG,MAAdjG,KACJsI,GAAgB,EAChB3C,EAASC,SACX0C,GAAgB,GAElB,IAAMC,EAASvI,EAAK+B,EAAW1C,KAAK0C,EAAWzC,KAC/C,GAAKgJ,EAUE,CACL,IAAME,EAAYxI,EAAK2F,EAAStG,KAAKsG,EAASrG,KAExC8C,EAAsBP,EAAS7B,EADvBA,EAAK8B,EAAUzC,KAAKyC,EAAUxC,KACMkJ,GAE5CjF,EAA2BD,EAA4BkF,GAC7D,EAAKV,wBACH1F,EACAmB,EACAiF,EACAD,OApBgB,CAClB,IACMnG,EAAsBP,EAAS7B,EADvBA,EAAK8B,EAAUzC,KAAKyC,EAAUxC,KACMiJ,GAC5ChF,EAA2BD,EAA4BiF,GAC7D,EAAKtB,gBACH7E,EACAmB,GACA,EACA,QA/YR,EA+ZE9B,WAAa,WACX,EAAK6F,mBACL,EAAK1F,aAGL,IALiB,IAIXsE,EADW,EAAKD,MAAdjG,KACawG,QACZ5B,EAAI,EAAGA,EAAIsB,EAAQzD,OAAQmC,IAClC,IAAK,IAAIK,EAAI,EAAGA,EAAIiB,EAAQtB,GAAGnC,OAAQwC,IAAK,CAC1C,IAAMsC,EAAUb,SAASC,eAAT,eAAgC/B,EAAhC,YAAqCK,IACrDsC,EAAQX,UAAUC,OAAO,gBACzBU,EAAQX,UAAUC,OAAO,sBACzBU,EAAQX,UAAUC,OAAO,qBAEzBU,EAAQX,UAAUC,OAAO,aACzBX,EAAQtB,GAAGK,GAAG1E,WAAY,EAC1B2F,EAAQtB,GAAGK,GAAGjD,SAAWC,IACzBiE,EAAQtB,GAAGK,GAAGxF,QAAS,EACvByG,EAAQtB,GAAGK,GAAG/C,aAAe,KAGjC,EAAKkE,SAAS,CAAEpG,KAAMkG,KAlb1B,EAobExE,UAAY,WACV,EAAK4F,mBAIL,IALgB,IAGVpB,EADW,EAAKD,MAAdjG,KACawG,QAEZ5B,EAAI,EAAGA,EAAIsB,EAAQzD,OAAQmC,IAClC,IAAK,IAAIK,EAAI,EAAGA,EAAIiB,EAAQtB,GAAGnC,OAAQwC,IAAK,CAE1C,IAAMsC,EAAUb,SAASC,eAAT,eAAgC/B,EAAhC,YAAqCK,IACrDsC,EAAQX,UAAUC,OAAO,gBACzBU,EAAQX,UAAUC,OAAO,sBACzBU,EAAQX,UAAUC,OAAO,qBACzBX,EAAQtB,GAAGK,GAAG1E,WAAY,EAC1B2F,EAAQtB,GAAGK,GAAGjD,SAAWC,IACzBiE,EAAQtB,GAAGK,GAAG/C,aAAe,KAGjC,EAAKkE,SAAS,CAAEpG,KAAMkG,KArc1B,EAucEuC,aAAe,SACbrG,EACAmB,EACA2D,EACAC,GAEA,IADI,IAAD,WACMvC,GACP,GAAIA,IAAMxC,EAAoBK,OAS5B,OARA2E,YAAW,WACJF,EAIH,EAAKG,oBAAoBF,GAFzB,EAAKE,oBAAoB9D,KAI1B,GAAKqB,GACF,CAAN,UAEFwC,YAAW,WACT,IAAM/G,EAAO+B,EAAoBwC,GAE3BvE,EAAKd,SAAWc,EAAKb,UAAYa,EAAKR,SAC1C6G,SAASC,eAAT,eAAgCtG,EAAKhB,IAArC,YAA4CgB,EAAKf,MAAOb,UACtD,uBAEH,GAAKmG,IAnBDA,EAAI,EAAGA,GAAKxC,EAAoBK,OAAQmC,IAAK,CAAC,IAAD,IAA7CA,GAA6C,oCA7c1D,EAmeE8D,qBAAuB,SACrBX,EACAC,EACAC,EACAC,GAEA,IADI,IAAD,WACMtD,GACP,GAAIA,IAAMmD,EAAuBtF,OAkB/B,OAjBA2E,YAAW,WAAO,IAEVhF,EAAsBsB,EADX,EAAKuC,MAAdjG,KACgCiI,EAAUC,GAC5CC,EAA4B7D,EAChC4D,GAEI3E,EAAwB,sBACzByE,GADyB,YAEzBG,IAEL,EAAKM,aACHrG,EACA+F,GACA,EACA5E,KAED,GAAKqB,GACF,CAAN,UAEFwC,YAAW,WACT,IAAM/G,EAAO0H,EAAuBnD,GAE9BvE,EAAKd,SAAWc,EAAKb,UAAYa,EAAKR,SAC1C6G,SAASC,eAAT,eAAgCtG,EAAKhB,IAArC,YAA4CgB,EAAKf,MAAOb,UACtD,4BAEH,GAAKmG,IA5BDA,EAAI,EAAGA,GAAKmD,EAAuBtF,OAAQmC,IAAK,CAAC,IAAD,IAAhDA,GAAgD,oCAze7D,EAwgBEpD,eAAiB,WAEf4D,EACE,iKACF,EAAKgD,iBACL,EAAKC,cACL,EAAK3G,YANgB,IAOb1B,EAAS,EAAKiG,MAAdjG,KACJsI,GAAgB,EAChB3C,EAASC,SACX0C,GAAgB,GAElB,IAAMK,EAAQ3I,EAAK8B,EAAUzC,KAAKyC,EAAUxC,KACtCiJ,EAASvI,EAAK+B,EAAW1C,KAAK0C,EAAWzC,KAC/C,GAAKgJ,EASE,CACL,IAAME,EAAYxI,EAAK2F,EAAStG,KAAKsG,EAASrG,KACxC8C,EAAsBsB,EAAM1D,EAAM2I,EAAOH,GACzCjF,EAA2Be,EAC/BkE,GAEF,EAAKE,qBACHtG,EACAmB,EACAiF,EACAD,OAnBgB,CAClB,IAAMnG,EAAsBsB,EAAM1D,EAAM2I,EAAOJ,GACzChF,EAA2Be,EAAiCiE,GAClE,EAAKE,aACHrG,EACAmB,GACA,EACA,QA7hBR,EA6iBE5B,QAAU,WACR,EAAKD,YACL0D,EACE,6IAHY,IAINpF,EAAS,EAAKiG,MAAdjG,KAJM,uBAKd,YAAkBA,EAAlB,+CAAwB,CAAC,IAAdX,EAAa,+BACtB,YAAmBA,EAAnB,+CAAwB,CAAC,IAAdgB,EAAa,QAClBA,EAAKhB,MAAQsG,EAAStG,KAAOgB,EAAKf,MAAQqG,EAASrG,MACrDe,EAAKZ,QAAS,EACdY,EAAKR,QAAS,IAJI,oFALV,kFAgBd8F,EAASC,QAAS,EAClBc,SAASC,eAAT,eAAgChB,EAAStG,IAAzC,YAAgDsG,EAASrG,MAAOb,UAC9D,iBACF,EAAK2H,SAAS,CAAEpG,SAChB0G,SAASC,eAAe,mBAAmBiC,UAAW,GAjkB1D,EAmkBEhH,WAAa,WACX8E,SAASC,eAAe,mBAAmBiC,UAAW,EAEtDxD,EACE,2KAJe,IAMTpF,EAAS,EAAKiG,MAAdjG,KACQ0G,SAASC,eAAT,eACNhB,EAAStG,IADH,YACUsG,EAASrG,MAE3BsH,UAAUC,OAAO,aAVR,2BAWjB,YAAkB7G,EAAlB,+CAAwB,CAAC,IAAdX,EAAa,+BACtB,YAAmBA,EAAnB,+CAAwB,SACjBQ,QAAS,GAFM,oFAXP,kFAgBjB8F,EAASC,QAAS,EAClB,EAAKQ,SAAS,CAAEpG,UAplBpB,EAslBE6I,gBAAkB,WAChB,OAAOjF,KAAKiB,MAAMjB,KAAKkF,UAAYrE,EAAiBD,KAvlBxD,EAylBEuE,eAAiB,WAAO,IAEhB7C,EADW,EAAKD,MAAdjG,KACawG,QAFA,uBAGrB,YAAkBN,EAAlB,+CAA2B,CAAC,IAAjB7G,EAAgB,+BACzB,YAAmBA,EAAnB,+CAAwB,SACjBI,QAAS,GAFS,oFAHN,kFAQrB,EAAK2G,SAAS,CAAEpG,KAAMkG,KAjmB1B,EAmmBE5E,eAAiB,WACf,EAAKI,YACL,EAAKqH,iBAFgB,IAGb/I,EAAS,EAAKiG,MAAdjG,KACFkG,EAAUlG,EAAKwG,QACjBlE,EAAQ,GALS,uBAMrB,YAAkBtC,EAAlB,+CAAwB,CAAC,IAAdX,EAAa,+BACtB,YAAmBA,EAAnB,+CAAwB,CAAC,IAAdgB,EAAa,QAGjBA,EAAKhB,MAAQsG,EAAStG,KAAOgB,EAAKf,MAAQqG,EAASrG,KACnDe,EAAKhB,MAAQyC,EAAUzC,KAAOgB,EAAKf,MAAQwC,EAAUxC,KACrDe,EAAKhB,MAAQ0C,EAAW1C,KAAOgB,EAAKf,MAAQyC,EAAWzC,KAG1DgD,EAAMC,KAAKlC,IATO,oFANH,kFAuBrB,IAJA,IAAI2I,EAAqB1G,EAAMG,OAC3BiC,EAAId,KAAKiB,MAAO,GAAYmE,GAC9BF,EAAS,EAAKD,kBAETnE,GAAG,CACR,QAAsBgD,IAAlBpF,EAAMwG,GAAuB,OACjC,QAA6BpB,IAAzBpF,EAAMwG,GAAQrJ,OAAsB,OACxC6C,EAAMwG,GAAQrJ,QAAU6C,EAAMwG,GAAQrJ,OACtCiF,GAAK,EAELoE,EAAS,EAAKD,kBAEhB,EAAKzC,SAAS,CAAEpG,KAAMkG,KAloB1B,EAooBEhF,2BAA6B,WAC3B,EAAKO,aACL,EAAK2G,iBACL,EAAKC,cAGL,IANiC,IAK3B/F,EAAQiC,EADG,EAAK0B,MAAdjG,KAC8BwE,GALL,WAMxByE,GAEP,QAAiBvB,IAAbpF,EAAM2G,GACR,MAAM,CAAN,UAGF7B,YAAW,WACH9E,EAAM2G,GAAG1J,SAAW+C,EAAM2G,GAAGzJ,UAAY8C,EAAM2G,GAAGpJ,SACtDyC,EAAM2G,GAAGxJ,QAAS,EACFiH,SAASC,eAAT,eACNrE,EAAM2G,GAAG5J,IADH,YACUiD,EAAM2G,GAAG3J,MAE3Bb,UAAY,uBAGDiJ,IAAjBpF,EAAM2G,EAAI,KACZ,EAAKrB,kBACL,EAAKC,gBAEF,GAAJoB,IAnBIA,EAAI,EAAGA,EAAI3G,EAAMG,OAAQwG,IAAK,CAAC,IAAD,IAA9BA,GAA8B,oCA1oB3C,EAgqBE9H,mBAAqB,WACnB,EAAKM,aACL,EAAK2G,iBACL,EAAKC,cAGL,IANyB,IAKnB/F,EAAQwC,EADG,EAAKmB,MAAdjG,KAC0BwE,GALT,WAMhByE,GACP,QAAiBvB,IAAbpF,EAAM2G,GACR,MAAM,CAAN,UAEF7B,YAAW,WACH9E,EAAM2G,GAAG1J,SAAW+C,EAAM2G,GAAGzJ,UAAY8C,EAAM2G,GAAGpJ,SACtDyC,EAAM2G,GAAGxJ,QAAS,EACFiH,SAASC,eAAT,eACNrE,EAAM2G,GAAG5J,IADH,YACUiD,EAAM2G,GAAG3J,MAE3Bb,UAAY,uBAEDiJ,IAAjBpF,EAAM2G,EAAI,KACZ,EAAKrB,kBACL,EAAKC,gBAEF,GAAJoB,IAhBIA,EAAI,EAAGA,EAAI3G,EAAMG,OAAQwG,IAAK,CAAC,IAAD,IAA9BA,GAA8B,oCAtqB3C,EAyrBE7H,mBAAqB,WACnB,EAAKK,aACL,EAAK2G,iBACL,EAAKC,cAGL,IANyB,IAKnB/F,EAAQyC,EADG,EAAKkB,MAAdjG,KACsBwE,EAAgBC,GALrB,WAMhBwE,GACP,QAAiBvB,IAAbpF,EAAM2G,GACR,MAAM,CAAN,UAEF7B,YAAW,WACH9E,EAAM2G,GAAG1J,SAAW+C,EAAM2G,GAAGzJ,UAAY8C,EAAM2G,GAAGpJ,SACtDyC,EAAM2G,GAAGxJ,QAAS,EACFiH,SAASC,eAAT,eACNrE,EAAM2G,GAAG5J,IADH,YACUiD,EAAM2G,GAAG3J,MAE3Bb,UAAY,uBAEDiJ,IAAjBpF,EAAM2G,EAAI,KACZ,EAAKrB,kBACL,EAAKC,gBAEF,GAAJoB,IAhBIA,EAAI,EAAGA,EAAI3G,EAAMG,OAAQwG,IAAK,CAAC,IAAD,IAA9BA,GAA8B,oCA/rB3C,EAktBE5H,kBAAoB,WAClB,EAAKI,aACL,EAAK2G,iBACL,EAAKC,cAGL,IANwB,IAKlB/F,EAAQ4C,EADG,EAAKe,MAAdjG,KACqBwE,EAAgBC,GALrB,WAMfwE,GACP,QAAiBvB,IAAbpF,EAAM2G,GACR,MAAM,CAAN,UAEF7B,YAAW,WACH9E,EAAM2G,GAAG1J,SAAW+C,EAAM2G,GAAGzJ,UAAY8C,EAAM2G,GAAGpJ,SACtDyC,EAAM2G,GAAGxJ,QAAS,EACFiH,SAASC,eAAT,eACNrE,EAAM2G,GAAG5J,IADH,YACUiD,EAAM2G,GAAG3J,MAE3Bb,UAAY,uBAEDiJ,IAAjBpF,EAAM2G,EAAI,KACZ,EAAKrB,kBACL,EAAKC,gBAEF,GAAJoB,IAhBIA,EAAI,EAAGA,EAAI3G,EAAMG,OAAQwG,IAAK,CAAC,IAAD,IAA9BA,GAA8B,oCAxtB3C,EA2uBEZ,YAAc,WAAO,IACXrI,EAAS,EAAKiG,MAAdjG,KADU,uBAElB,YAAkBA,EAAlB,+CAAwB,CAAC,IAAdX,EAAa,+BACtB,YAAmBA,EAAnB,+CAAwB,CAAC,IAAdgB,EAAa,QACNqG,SAASC,eAAT,eAAgCtG,EAAKhB,IAArC,YAA4CgB,EAAKf,MACzDT,MAAMqK,cAAgB,QAHV,oFAFN,oFA3uBtB,EAovBErB,WAAa,WAAO,IACV7H,EAAS,EAAKiG,MAAdjG,KADS,uBAEjB,YAAkBA,EAAlB,+CAAwB,CAAC,IAAdX,EAAa,+BACtB,YAAmBA,EAAnB,+CAAwB,CAAC,IAAdgB,EAAa,QACNqG,SAASC,eAAT,eAAgCtG,EAAKhB,IAArC,YAA4CgB,EAAKf,MACzDT,MAAMqK,cAAgB,QAHV,oFAFP,oFApvBrB,EA6vBEd,eAAiB,WAEf,IADA,IAAMe,EAAUzC,SAAS0C,uBAAuB,OACvCH,EAAI,EAAGA,EAAIE,EAAQ1G,OAAQwG,IAClCE,EAAQF,GAAGL,UAAW,GAhwB5B,EAmwBEhB,gBAAkB,WAGhB,IAFA,IAAMuB,EAAUzC,SAAS0C,uBAAuB,OAEvCH,EAAI,EAAGA,EAAIE,EAAQ1G,OAAQwG,IAClCE,EAAQF,GAAGL,UAAW,EAGpBjD,EAASC,SACXc,SAASC,eAAe,mBAAmBiC,UAAW,IA3wB5D,+EAMI,IAAMS,EAAe3C,SAASC,eAAe,iBAAiB2C,aACxDC,EAAaC,OAAOC,aAAeJ,EAAe,KAClDK,EAAYhD,SAASC,eAAe,eAAegD,YACzDnF,EAAiBZ,KAAKiB,MAAM0E,EAAa,GAAK,GAC9C9E,EAAiBb,KAAKiB,MAAM6E,EAAY,IACxCrE,EAAiBzB,KAAKiB,MAAML,EAAiB,GAC7Cc,EAAiB1B,KAAKiB,MAAMJ,EAAiB,GAC7Cc,EAAkB3B,KAAKiB,MAAML,EAAiB,GAC9CgB,EAAkB5B,KAAKiB,MAAMJ,EAAiB,MAC9CgB,EAAgB7B,KAAKiB,MAAML,EAAiB,KAC5CkB,EAAgB9B,KAAKiB,MAAMJ,EAAiB,KAC5C3C,EAAUzC,IAAMgG,EAChBvD,EAAUxC,IAAMgG,EAChBvD,EAAW1C,IAAMkG,EACjBxD,EAAWzC,IAAMkG,EACjBG,EAAStG,IAAMoG,EACfE,EAASrG,IAAMoG,IAtBnB,0CAyBIvG,KAAKyK,gBACL,IAAM5J,EAAOb,KAAK2H,iBAClB3H,KAAKiH,SAAS,CAAEpG,WA3BpB,+BA8wBY,IAAD,OACD6J,EAAU,CACdC,MAAO,QACPhL,gBAAiB,aACjBiL,QAAS,QACTC,WAAY,QAEZC,YAAa,SACbC,QAAS,eACTC,aAAc,MACdC,UAAW,UAGb,OACE,6BACE,yBAAK3L,UAAU,MAAMC,GAAG,eACtB,yBAAKA,GAAG,iBACN,kBAAC,EAAD,CACE6C,kBAAmB,kBAAM,EAAKA,qBAC9BC,eAAgB,kBAAM,EAAKA,kBAC3BC,WAAY,kBAAM,EAAKA,cACvBC,UAAW,kBAAM,EAAKA,aACtBC,QAAS,kBAAM,EAAKA,WACpBC,WAAY,kBAAM,EAAKA,cACvBN,eAAgB,kBAAM,EAAKA,kBAC3BJ,2BAA4B,kBAC1B,EAAKA,8BAEPC,mBAAoB,kBAAM,EAAKA,sBAC/BC,mBAAoB,kBAAM,EAAKA,sBAC/BC,kBAAmB,kBAAM,EAAKA,wBAGlC,yBAAK3C,GAAG,eACN,kBAAC,IAAD,CAASC,gBAAgB,SAASC,GAAG,SACnC,4BACEH,UAAU,uBACVI,MAAO,CAAEwL,MAAO,QAChB3L,GAAG,eAHL,eAQF,yBAAKG,MAAOgL,GACV,yBAAKnL,GAAG,kBACN,yBAAKA,GAAG,iBAAR,KADF,cAGA,yBAAKA,GAAG,kBACN,yBAAKA,GAAG,kBAAR,KADF,mBAGA,yBAAKA,GAAG,kBACN,yBAAKA,GAAG,qBAAR,MAEF,yBAAKA,GAAG,kBACN,yBAAKA,GAAG,qBAAR,KADF,kBAGA,yBAAKA,GAAG,kBACN,yBAAKA,GAAG,kBAAR,KADF,eAGA,yBAAKA,GAAG,kBACN,yBAAKA,GAAG,mBAAR,KADF,gBAGA,yBAAKA,GAAG,kBACN,yBAAKA,GAAG,iBAAR,KADF,cAGA,yBAAKA,GAAG,kBACN,yBAAKA,GAAG,qBAAR,KADF,uBAIF,4BAAQG,MAAOgL,GAAUzE,IAE3B,yBAAK1G,GAAG,eACN,kBAAC,EAAD,CACEsB,KAAMb,KAAK8G,MAAMjG,KACjBC,eAAgBd,KAAK8G,MAAMhG,eAC3BO,cAAe,SAACnB,EAAKC,GAAN,OAAc,EAAKkB,cAAcnB,EAAKC,IACrDoB,iBAAkB,SAACrB,EAAKC,GAAN,OAAc,EAAKoB,iBAAiBrB,EAAKC,IAC3DmB,gBAAiB,SAACpB,EAAKC,GAAN,OAAc,EAAKmB,gBAAgBpB,EAAKC,aA31BvE,GAAyBL,aChCVqL,EAVf,iLAEI,OACE,6BACE,8CAJR,GAA8BrL,aCUVsL,QACW,cAA7Bf,OAAOgB,SAASC,UAEe,UAA7BjB,OAAOgB,SAASC,UAEhBjB,OAAOgB,SAASC,SAASC,MACvB,2D,UCCAC,EACJ,kBAAC,IAAD,KACE,6BAaE,kBAAC,IAAD,KACE,kBAAC,IAAD,CAAOC,OAAK,EAACC,KAAK,IAAIC,UAAW9E,IACjC,kBAAC,IAAD,CAAO6E,KAAK,QAAQC,UAAWtM,IAC/B,kBAAC,IAAD,CACEqM,KAAK,WACLC,UAAW,WAET,OADAtB,OAAOgB,SAAS3J,KAAO,4CAChB,QAGX,kBAAC,IAAD,CAAOiK,UAAWR,OAO1BS,IAASC,OAAOL,EAASjE,SAASC,eAAe,SDgF3C,kBAAmBsE,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.b78af0c3.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./demo.css\";\nimport {\n  Route,\n  NavLink,\n  // BrowserRouter as Router,\n  HashRouter as Router,\n  Switch\n} from \"react-router-dom\";\nclass Demo extends React.Component {\n  render() {\n    return (\n      <div>\n        <button className=\"btn btn-lg\" id=\"visualizePathButton\">\n          <NavLink activeClassName=\"active\" to=\"/\">\n            Visaulize Paths !\n          </NavLink>\n        </button>\n        <div className=\"container\">\n          <div id=\"header\">\n            <h1 style={{ backgroundColor: \"lightblue\" }}>\n              How to use this tool ?\n              <small className=\"text-muted\">..and what the heck is A* ??</small>\n            </h1>\n            <blockquote\n              className=\"blockquote text-center font-italic font-weight-bold\"\n              style={{ backgroundColor: \"ghostwhite\" }}\n            >\n              <p className=\"mb-0\">\n                Shortest Distance between two points is a straight line.\n              </p>\n              <footer className=\"blockquote-footer\">\n                <cite title=\"Source Title\">Archimedes</cite>\n              </footer>\n            </blockquote>\n            <h5 className=\"font-weight-bold\">\n              {\" \"}\n              <NavLink activeClassName=\"active\" to=\"/article\">\n                Click Here\n              </NavLink>{\" \"}\n              if you want to learn more about path finding algorithms ..\n            </h5>\n          </div>\n          <div id=\"parentInfoDiv\">\n            <div id=\"alignHelperDiv\">\n              <div id=\"wallNodeImage\"> </div> Wall Node\n            </div>\n            <div id=\"alignHelperDiv\">\n              <div id=\"emptyNodeImage\"> </div> Unvisited Node\n            </div>\n            <div id=\"alignHelperDiv\">\n              <div id=\"visitedNodeImage1\"> </div>\n            </div>\n            <div id=\"alignHelperDiv\">\n              <div id=\"visitedNodeImage2\"> </div> Visited Nodes\n            </div>\n            <div id=\"alignHelperDiv\">\n              <div id=\"startNodeImage\"> </div> Start Node\n            </div>\n            <div id=\"alignHelperDiv\">\n              <div id=\"finishNodeImage\"> </div> Finish Node\n            </div>\n            <div id=\"alignHelperDiv\">\n              <div id=\"bombNodeImage\"> </div> Bomb Node\n            </div>\n            <div id=\"alignHelperDiv\">\n              <div id=\"shortestPathImage\"> </div>Shortest Path Node\n            </div>\n          </div>\n          <div id=\"listItems\">\n            <ul className=\"list-group\">\n              <li className=\"list-group-item\">\n                <h6>\n                  {\" \"}\n                  <strong>\n                    {\" \"}\n                    1. Click and drag on the grid to draw walls, so that\n                    algorithm doesn't go through the walls and find shortest\n                    path to finish node around it .\n                  </strong>\n                </h6>\n                <div id=\"drawingWallsImage\"></div>\n              </li>\n              <li className=\"list-group-item\">\n                <h6>\n                  <strong>2. Select an algorithm to visualize !</strong>\n                </h6>\n                <div id=\"selectAlgorithmImage\"></div>\n              </li>\n              <li className=\"list-group-item\">\n                <h6>\n                  <strong>\n                    3. After this the algorithm finds the shortest path to the\n                    finish node according to the selected algorithm.\n                  </strong>\n                </h6>\n                <div id=\"path1SampleImage\"></div>\n              </li>\n              <li className=\"list-group-item\">\n                <h6>\n                  <strong>\n                    4. Click on Add Bomb to add a bomb Node on the grid.\n                  </strong>\n                </h6>\n                <div id=\"clickOnBombNodeImage\"></div>\n              </li>\n              <li className=\"list-group-item\">\n                <h6>\n                  <strong>\n                    5. When Bomb Node is active the algorithm finds the path\n                    first to bombNode to deactivate it and then to the finish\n                    node.\n                  </strong>\n                </h6>\n                <div id=\"travelThroughBombNode\"></div>\n              </li>\n              <li className=\"list-group-item\">\n                <h6>\n                  <strong>\n                    6. You can also select from one of some built-in mazes to\n                    draw walls on the grid.\n                  </strong>\n                </h6>\n                <div id=\"selectMazes\"></div>\n              </li>\n              <li className=\"list-group-item\">\n                <h6>\n                  <strong>Here are few sample snippets ...</strong>\n                </h6>\n                <div id=\"sample01\"></div>\n              </li>\n              <li className=\"list-group-item\">\n                <h6></h6>\n                <div id=\"sample02\"></div>\n              </li>\n            </ul>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\nexport default Demo;\n","import React, { Component } from \"react\";\nimport \"./Node.css\";\n\nexport class Node extends Component {\n  render() {\n    const {\n      row,\n      col,\n      isStart,\n      isFinish,\n      isWall,\n      onMouseUp,\n      onMouseEnter,\n      onMouseDown,\n      isBomb\n    } = this.props;\n    const extraClassName = isFinish\n      ? \"node-finish\"\n      : isStart\n      ? \"node-start\"\n      : isWall\n      ? \"node-wall\"\n      : isBomb\n      ? \"node-bomb\"\n      : \"\";\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp(row, col)}\n      ></div>\n    );\n  }\n}\n\nexport default Node;\n","import React, { Component } from \"react\";\nimport Node from \"./Node/Node\";\n\nimport \"./PathfindingVisualizer.css\";\n\nexport class PathfindingVisualizer extends Component {\n  render() {\n    const { grid, mouseIsPressed } = this.props;\n    return (\n      <div>\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx} className=\"row\">\n                {row.map((node, nodeIdx) => {\n                  const {\n                    row,\n                    col,\n                    isStart,\n                    isFinish,\n                    isWall,\n                    isVisited,\n                    isBomb\n                  } = node;\n                  return (\n                    <Node\n                      isBomb={isBomb}\n                      isVisited={isVisited}\n                      key={nodeIdx}\n                      col={col}\n                      row={row}\n                      mouseIsPressed={mouseIsPressed}\n                      isWall={isWall}\n                      isStart={isStart}\n                      isFinish={isFinish}\n                      onMouseUp={(row, col) =>\n                        this.props.handleMouseUp(row, col)\n                      }\n                      onMouseDown={(row, col) =>\n                        this.props.handleMouseDown(row, col)\n                      }\n                      onMouseEnter={(row, col) =>\n                        this.props.handleMouseEnter(row, col)\n                      }\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default PathfindingVisualizer;\n","import React, { Component } from \"react\";\nclass NavBar extends Component {\n  render() {\n    return (\n      <React.Fragment>\n        <nav className=\"navbar navbar-dark bg-dark mb-3 mw-100\">\n          <a href=\".\">\n            <h3 className=\"text-white\">PathFinding Visualizer </h3>\n          </a>\n          <div\n            className=\"btn-toolbar\"\n            role=\"toolbar\"\n            aria-label=\"Toolbar with button groups\"\n          >\n            <div\n              className=\"btn-group mr-2\"\n              role=\"group\"\n              aria-label=\"First group\"\n            >\n              <button\n                type=\"button\"\n                className=\"btn btn-secondary\"\n                // disabled\n                title=\"Generate different mazes \"\n              >\n                Mazes\n              </button>\n              <button\n                type=\"button\"\n                className=\"btn btn-secondary \"\n                title=\"Recursive Division maze\"\n                onClick={() => this.props.visualizeRecursiveDivision()}\n              >\n                M1\n              </button>\n              <button\n                type=\"button\"\n                className=\"btn btn-secondary\"\n                title=\"Simple staircase maze\"\n                onClick={() => this.props.visualizeStaircase()}\n              >\n                M2\n              </button>\n              <button\n                type=\"button\"\n                className=\"btn btn-secondary \"\n                title=\"Maze 3\"\n                onClick={() => this.props.visualizeMazeThree()}\n              >\n                M3\n              </button>\n              <button\n                type=\"button\"\n                className=\"btn btn-secondary\"\n                title=\"Recursive division staircase maze \"\n                onClick={() => this.props.visualizeMazeFour()}\n              >\n                M4\n              </button>\n              <button\n                type=\"button\"\n                className=\"btn btn-secondary \"\n                title=\"Generate Random walls\"\n                onClick={() => {\n                  this.props.genRandomWalls();\n                }}\n              >\n                M5\n              </button>\n            </div>\n          </div>\n          <div>\n            <button\n              className=\"btn btn-outline-danger m-1 btn-sm\"\n              title=\"Visualize dijkstra algoritm!\"\n              onClick={() => {\n                this.props.visualizeDijkstra();\n              }}\n            >\n              Visualize Dijkstra\n            </button>\n            <button\n              className=\"btn btn-outline-danger m-1 btn-sm\"\n              title=\"Visualize A* algorithm\"\n              onClick={() => {\n                this.props.visualizeAstar();\n              }}\n            >\n              Visualize Astar\n            </button>\n            <button\n              className=\"btn btn-outline-primary m-1 btn-sm\"\n              title=\"Clear entire board\"\n              onClick={() => this.props.clearBoard()}\n            >\n              Clear Board\n            </button>\n            <button\n              className=\"btn btn-outline-primary m-1 btn-sm\"\n              title=\"Clear Shortest Path\"\n              onClick={() => this.props.clearPath()}\n            >\n              Clear Path\n            </button>\n            <button\n              className=\"btn btn-outline-primary m-1 btn-sm\"\n              id=\"add-bomb-button\"\n              title=\"Add bomb Node!\"\n              onClick={() => this.props.addBomb()}\n            >\n              Add Bomb\n            </button>\n            <button\n              className=\"btn btn-outline-primary m-1 btn-sm\"\n              title=\"Remove Bomb Node\"\n              onClick={() => this.props.removeBomb()}\n            >\n              Remove Bomb\n            </button>\n\n            <button\n              className=\"btn btn-outline-primary m-1 btn-sm\"\n              title=\"Generate Random walls\"\n              onClick={() => this.props.genRandomWalls()}\n            >\n              Generate Random walls\n            </button>\n          </div>\n        </nav>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default NavBar;\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\n\nexport function dijkstra(grid, startNode, finishNode) {\n  setAllDistanceToInfinity(grid);\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    //after sorting closest node can be any of the four/three/two/one options as we are updating all the neighbors(of a node) distance by +1.\n    //\n    const closestNode = unvisitedNodes.shift();\n    //if we encounter a wall we don't do anything\n    if (closestNode.isWall) continue;\n    //if distance of closest node is infinity\n    //we must be trapped and should stop\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\nfunction setAllDistanceToInfinity(grid) {\n  for (const row of grid) {\n    for (const node of row) {\n      node.distance = Infinity;\n      node.isVisited = false;\n      node.previousNode = null;\n    }\n  }\n}\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (let neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { row, col } = node;\n  //to check closestNode is not in the first row ( we are selecting the top element){so if row is 0 for node we are checking neighbors of, there is nothing on top of it, i.e why row must be greater than 0, similar goes for the rest three sides}\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  //to check if startNode is not in the last row(we are selecting the below element)\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  //to check if startNode is not in far left(first column),(we are selecting left of closestNode)\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  //to check if the element is not in the far right, in the last col(we are selecting the right side neighbor)\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  //  // if (col < grid.length - 1) neighbors.push(grid[row][col + 1]); -- this will compare the\n  //col value with grid.length which is total row value, we want to check with col value\n\n  //then filter among them whichever is unvisited\n  //so unvisitedNeighbors in getUnvisitedNeighbors function will not always get 4 neighbors\n  //like in second iteration of while loop we will get 3 neighbor nodes whether we select any four\n  // from the first as the closestNode was already visited\n  //filter takes in a function and returns array which passes the constraints of that function\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  //current node will be null it is equal to startNode\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","//similar to dijkstra's algorithms but we also calculate the heuristic distance of each node to select the best node to reach the finish node\n//f = g + h ; g= distance from startNode; h=heuristic distance(estimated distance to finish node)\n// With A*,we see that once we get past the obstacle, the algorithm prioritizes the node with the lowest f and the ‘best’ chance of reaching the end.\nexport function astar(grid, startNode, finishNode) {\n  setAllDistanceToInfinity(grid);\n\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  addHeuristicDistanceToNodes(grid, startNode, finishNode);\n  const unvisitedNodes = getAllNodes(grid);\n  while (unvisitedNodes.length) {\n    sortNodesByTotalDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\nfunction setAllDistanceToInfinity(grid) {\n  for (const row of grid) {\n    for (const node of row) {\n      node.distance = Infinity;\n      node.isVisited = false;\n      node.previousNode = null;\n    }\n  }\n}\n//same as dijkstra that we update the distance of neighbouring nodes by +1 and also we compute total distance as distance + heuristic distance\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  // console.log(unvisitedNeighbors);\n  for (let neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.totalDistance = node.distance + 1 + neighbor.heuristicDistance;\n\n    neighbor.previousNode = node;\n  }\n}\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { row, col } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  //  // diagnal elements\n  // // top-right\n  // if (row > 0 && col < grid[0].length - 1)\n  //   neighbors.push(grid[row - 1][col + 1]);\n  // // bottom-right\n  //  if (row < grid.length - 1 && col < grid[0].length - 1)\n  //   neighbors.push(grid[row + 1][col + 1]);\n  // // bottom-left\n  // if (row < grid.length - 1 && col > 0) neighbors.push(grid[row + 1][col - 1]);\n  // // top-left\n  // if (row > 0 && col > 0) neighbors.push(grid[row - 1][col - 1]);\n\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\nfunction sortNodesByTotalDistance(unvisitedNodes) {\n  unvisitedNodes.sort(\n    (nodeA, nodeB) => nodeA.totalDistance - nodeB.totalDistance\n  );\n}\nfunction addHeuristicDistanceToNodes(grid, startNode, finishNode) {\n  for (const row of grid) {\n    for (const node of row) {\n      const a = Math.abs(finishNode.col - node.col);\n      const b = Math.abs(finishNode.row - node.row);\n      const h = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n      //adding random value to h to enhace the value of heuristic distance\n      //if we enhanced the value too much(i.e multiply by 5/10/100, shortest path will be more strict, i.e it would choose a deviated path instead of straight line. therefore some average value is added or multiplied\n      node.heuristicDistance = h + 1000;\n\n      node.totalDistance = node.distance + node.heuristicDistance;\n    }\n  }\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\nexport function getNodesInShortestPathOrderAstar(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  //current node will be null it is equal to startNode\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","//for all algortihms we are repeating a pattern number of times('w' times using while loop), and nodes array is being returned which has length greater than number of nodes in the grid which we are pruning(returning at that point when nodes[i]===undefined) while visualizing it.\nexport function recursiveDivision(grid, NUMBER_OF_ROWS, NUMBER_OF_COLS) {\n  let nodes = [];\n  let x = 1;\n  const row = NUMBER_OF_ROWS;\n  let w = 10;\n  // up,right,down,right lines & then repeat w times\n  while (w) {\n    //up\n    for (let i = row - 2; i >= 1; i--) {\n      if (i === Math.floor((row - 2) / 1.6)) continue;\n      if (i === Math.floor((row - 2) / 2.5)) continue;\n\n      nodes.push(grid[i][x]);\n    }\n    x += 1;\n    //right\n    for (let i = 0; i <= 4; i++) {\n      nodes.push(grid[1][x]);\n      x += 1;\n    }\n    //down\n    for (let i = 1; i < row - 1; i++) {\n      if (i === Math.floor((row - 2) / 1.2)) continue;\n      if (i === Math.floor((row - 2) / 3)) continue;\n      nodes.push(grid[i][x]);\n    }\n    //right\n    for (let i = 0; i <= 4; i++) {\n      nodes.push(grid[row - 2][x]);\n      x += 1;\n    }\n    w -= 1;\n  }\n  return nodes;\n}\n","export function staircaseMaze(grid, NUMBER_OF_ROWS, NUMBER_OF_COLS) {\n  const row = NUMBER_OF_ROWS;\n  let nodes = [];\n  let x = 0;\n  let w = 10;\n  while (w) {\n    for (let i = row - 1; i >= 1; i--) {\n      if (i === Math.floor((row - 2) / 4)) continue;\n      if (i === Math.floor((row - 2) / 1.2)) continue;\n\n      nodes.push(grid[i][x]);\n      x += 1;\n    }\n    for (let i = 1; i < row - 2; i++) {\n      if (i === Math.floor((row - 2) / 2)) continue;\n      if (i === Math.floor((row - 2) / 1.2)) continue;\n\n      nodes.push(grid[i][x]);\n      x += 1;\n    }\n    w -= 1;\n  }\n  return nodes;\n}\n","export function mazeThree(grid, NUMBER_OF_ROWS, NUMBER_OF_COLS) {\n  let nodes = [];\n  const row = NUMBER_OF_ROWS;\n  const col = NUMBER_OF_COLS;\n  for (let i = Math.floor(row / 1.8); i < Math.floor(row / 2.8); i++) {\n    nodes.push(grid[i][Math.floor(col / 3)]);\n  }\n  // outer rectanlge\n  //up\n  for (let i = 1; i < col - 1; i++) {\n    nodes.push(grid[0][i]);\n  }\n  //bottom\n  for (let i = 1; i < col - 1; i++) {\n    nodes.push(grid[row - 1][i]);\n  }\n  //left\n  for (let i = 1; i < row - 1; i++) {\n    nodes.push(grid[i][1]);\n  }\n  //right\n  for (let i = 1; i < row - 1; i++) {\n    nodes.push(grid[i][col - 2]);\n  }\n  // while (w) {\n  let q = 6;\n  for (let j = 1; j < 20; j++) {\n    //below four for loops are for four bars\n    //top bar\n    for (let i = 1; i < Math.floor(row / 2); i++) {\n      if (i === Math.floor((row - 2) / 1.6)) continue;\n      if (i === Math.floor((row - 2) / 2.5)) continue;\n      nodes.push(grid[i][q]);\n    }\n    //bottom bar\n    for (let i = row - 1; i > Math.floor(row / 2.2); i--) {\n      if (i === Math.floor((row - 2) / 1.6)) continue;\n      if (i === Math.floor((row - 2) / 2.5)) continue;\n      nodes.push(grid[i][q]);\n    }\n    //top second bar\n    q += 6;\n    for (let i = 1; i < Math.floor(row / 2); i++) {\n      if (i === Math.floor((row - 2) / 1.6)) continue;\n      if (i === Math.floor((row - 2) / 2.5)) continue;\n      nodes.push(grid[i][q]);\n    }\n    //bottom second bar\n    for (let i = row - 1; i > Math.floor(row / 2); i--) {\n      if (i === Math.floor((row - 2) / 1.6)) continue;\n      if (i === Math.floor((row - 2) / 2.5)) continue;\n      nodes.push(grid[i][q]);\n    }\n  }\n  return nodes;\n}\n","export function mazeFour(grid, NUMBER_OF_ROWS, NUMBER_OF_COLS) {\n  let nodes = [];\n  const row = NUMBER_OF_ROWS;\n  const col = NUMBER_OF_COLS;\n  for (let i = Math.floor(row / 1.8); i < Math.floor(row / 2.8); i++) {\n    nodes.push(grid[i][Math.floor(col / 3)]);\n  }\n  // outer rectanlge\n  //up\n  for (let i = 0; i < col; i++) {\n    nodes.push(grid[0][i]);\n  }\n  //bottom\n  for (let i = 0; i < col; i++) {\n    nodes.push(grid[row - 1][i]);\n  }\n  //left\n  for (let i = 0; i < row - 1; i++) {\n    nodes.push(grid[i][1]);\n  }\n  //right\n  for (let i = 0; i < row - 1; i++) {\n    nodes.push(grid[i][col - 2]);\n  }\n  let x = 0;\n  let y = 1;\n  let w = 10;\n  while (w) {\n    for (let i = row - 1; i >= 1; i--) {\n      if (i === Math.floor((row - 2) / 4)) continue;\n      if (i === Math.floor((row - 2) / 1.2)) continue;\n\n      nodes.push(grid[i][x]);\n      x += 1;\n    }\n    for (let i = 0; i <= row - 1; i++) {\n      if (i === Math.floor((row - 2) / 4)) continue;\n      if (i === Math.floor((row - 2) / 1.2)) continue;\n\n      nodes.push(grid[i][y]);\n      y += 1;\n    }\n    for (let i = 1; i < row - 2; i++) {\n      if (i === Math.floor((row - 2) / 2)) continue;\n      if (i === Math.floor((row - 2) / 1.2)) continue;\n\n      nodes.push(grid[i][x]);\n      x += 1;\n    }\n    for (let i = row - 3; i > 0; i--) {\n      if (i === Math.floor((row - 2) / 2)) continue;\n      if (i === Math.floor((row - 2) / 1.2)) continue;\n\n      nodes.push(grid[i][y]);\n      y += 1;\n    }\n    w -= 1;\n  }\n  return nodes;\n}\n","import React, { Component } from \"react\";\nimport {\n  Route,\n  NavLink,\n  // BrowserRouter as Router,\n  HashRouter as Router,\n  Switch\n} from \"react-router-dom\";\nimport Demo from \"./animations/Demo\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\nimport NavBar from \"./PathfindingVisualizer/NavBar\";\nimport \"./App.css\";\nimport { dijkstra, getNodesInShortestPathOrder } from \"./algorithms/dijkstra\";\nimport { astar, getNodesInShortestPathOrderAstar } from \"./algorithms/astar\";\nimport { recursiveDivision } from \"./mazeAlgorithms/recursiveDivision\";\nimport { staircaseMaze } from \"./mazeAlgorithms/staircaseMaze\";\nimport { mazeThree } from \"./mazeAlgorithms/maze3\";\nimport { mazeFour } from \"./mazeAlgorithms/maze4\";\nlet centerText =\n  \"Click and drag mouse on the grid to draw obstacles(or select from different mazes), then click on the algorithm to find the shortest path ;) (try adding a bomb also...)\";\nlet NUMBER_OF_ROWS = 22,\n  NUMBER_OF_COLS = 56;\nlet START_NODE_ROW = 10,\n  START_NODE_COL = 10,\n  FINISH_NODE_ROW = 10,\n  FINISH_NODE_COL = 40,\n  BOMB_NODE_ROW = 18,\n  BOMB_NODE_COL = 25;\nlet startNode = {\n  row: START_NODE_ROW,\n  col: START_NODE_COL\n};\nlet finishNode = {\n  row: FINISH_NODE_ROW,\n  col: FINISH_NODE_COL\n};\nlet bombNode = {\n  row: BOMB_NODE_ROW,\n  col: BOMB_NODE_COL,\n  status: false\n};\nlet draggingStart = false,\n  draggingFinish = false,\n  draggingBomb = false;\nexport class App extends Component {\n  state = {\n    grid: [],\n    mouseIsPressed: false\n  };\n  getWindowSize() {\n    const navBarHeight = document.getElementById(\"navBarContent\").clientHeight;\n    const gridHeight = window.innerHeight - (navBarHeight + 100);\n    const gridWidth = document.getElementById(\"gridContent\").clientWidth;\n    NUMBER_OF_ROWS = Math.floor(gridHeight / 25 - 1);\n    NUMBER_OF_COLS = Math.floor(gridWidth / 25);\n    START_NODE_ROW = Math.floor(NUMBER_OF_ROWS / 2);\n    START_NODE_COL = Math.floor(NUMBER_OF_COLS / 6);\n    FINISH_NODE_ROW = Math.floor(NUMBER_OF_ROWS / 2);\n    FINISH_NODE_COL = Math.floor(NUMBER_OF_COLS / 1.15);\n    BOMB_NODE_ROW = Math.floor(NUMBER_OF_ROWS / 1.2);\n    BOMB_NODE_COL = Math.floor(NUMBER_OF_COLS / 2.2);\n    startNode.row = START_NODE_ROW;\n    startNode.col = START_NODE_COL;\n    finishNode.row = FINISH_NODE_ROW;\n    finishNode.col = FINISH_NODE_COL;\n    bombNode.row = BOMB_NODE_ROW;\n    bombNode.col = BOMB_NODE_COL;\n  }\n  componentDidMount() {\n    this.getWindowSize();\n    const grid = this.getInitialGrid();\n    this.setState({ grid });\n  }\n  //mouse is pressed and not lifted up\n  handleMouseDown = (row, col) => {\n    this.clearPath();\n    const node = {\n      row: row,\n      col: col\n    };\n    if (node.row === startNode.row && node.col === startNode.col) {\n      const newGrid = this.getNewGridWithStartNodeToggled(\n        this.state.grid,\n        row,\n        col\n      );\n      // we don't want to create walls when we are dragging the start/finish node\n      //mouseIsPressed is set to false so that onMouseEnter doesn't trigger\n      this.setState({ grid: newGrid, mouseIsPressed: false });\n      draggingStart = true;\n    } else if (node.row === finishNode.row && node.col === finishNode.col) {\n      const newGrid = this.getNewGridWithFinishNodeToggled(\n        this.state.grid,\n        row,\n        col\n      );\n      this.setState({ grid: newGrid, mouseIsPressed: false });\n      draggingFinish = true;\n    } else if (\n      node.row === bombNode.row &&\n      node.col === bombNode.col &&\n      bombNode.status //checking with status so it triggers only when addBomb is clicked else it will create a wall on that node\n    ) {\n      const newGrid = this.getNewGridWithBombNodeToggled(\n        this.state.grid,\n        row,\n        col\n      );\n      this.setState({ grid: newGrid, mouseIsPressed: false });\n      draggingBomb = true;\n    } else {\n      const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({ grid: newGrid, mouseIsPressed: true });\n    }\n  };\n  //hovering over an element\n  //we want walls to be created when mouse is pressed and then dragged\n  //**mouseEnter will won't work when we clicked start/finish node, as we are setting\n  //mouseIsPressed as false in onMouseDown function(on the start/finish node)\n\n  handleMouseEnter = (row, col) => {\n    if (!this.state.mouseIsPressed) return;\n    //below if statement to prevent dragging and forming wall node over the bomb node(mouseIsPressed set to false not working here)\n    //remove this if condition with only bombNode condition if problem persists\n    if (\n      !(\n        (row === bombNode.row && col === bombNode.col) ||\n        (row === startNode.row && col === startNode.col) ||\n        (row === finishNode.row && col === finishNode.col)\n      )\n    ) {\n      const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({ grid: newGrid });\n    }\n  };\n  //when pressed mouse button is released\n  handleMouseUp = (row, col) => {\n    if (draggingStart) {\n      const newGrid = this.getNewGridWithStartNodeToggled(\n        this.state.grid,\n        row,\n        col\n      );\n      this.setState({ grid: newGrid });\n    } else if (draggingFinish) {\n      const newGrid = this.getNewGridWithFinishNodeToggled(\n        this.state.grid,\n        row,\n        col\n      );\n      this.setState({ grid: newGrid });\n    } else if (draggingBomb) {\n      const newGrid = this.getNewGridWithBombNodeToggled(\n        this.state.grid,\n        row,\n        col\n      );\n      this.setState({ grid: newGrid });\n    }\n    this.setState({ mouseIsPressed: false });\n    //resetting the dragging start/finish when mouse is lifted up\n    draggingStart = false;\n    draggingFinish = false;\n    draggingBomb = false;\n  };\n  getNewGridWithBombNodeToggled = (grid, row, col) => {\n    bombNode.row = row;\n    bombNode.col = col;\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isBomb: !node.isBomb,\n      isWall: false\n    };\n    const element = document.getElementById(\n      `node-${bombNode.row}-${bombNode.col}`\n    );\n\n    element.classList.remove(\"node-bomb\");\n    newGrid[row][col] = newNode;\n    //adding className to new node (was working fine without this also), check it later\n    // const newElement = document.getElementById(\n    //   `node-${bombNode.row}-${bombNode.col}`\n    // );\n    // newElement.className = \"node node-bomb\";\n    return newGrid;\n  };\n  getNewGridWithStartNodeToggled = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    startNode.row = row;\n    startNode.col = col;\n    const newNode = {\n      ...node,\n      isStart: !node.isStart,\n      //maybe due to mouse click problem wall is set to true and we are not getting anything\n      //in the visitedNodesInOrder from the dijkstra\n      // *isWall is set to false also bcoz, in case we put walls first and then move the start/finish node on that wall\n\n      isWall: false\n      // distance: Infinity\n      //distance setting to infinity not working, alternative is clearPath function\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n  getNewGridWithFinishNodeToggled = (grid, row, col) => {\n    const newGrid = grid.slice();\n    finishNode.row = row;\n    finishNode.col = col;\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isFinish: !node.isFinish,\n      isWall: false\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n  //changing the wall state\n  getNewGridWithWallToggled = (grid, row, col) => {\n    // if (row !== bombNode.row && col !== bombNode.col) {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n\n    const newNode = {\n      ...node,\n      isWall: !node.isWall\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n  getInitialGrid = () => {\n    let grid = [];\n    for (let row = 0; row < NUMBER_OF_ROWS; row++) {\n      let currentRow = [];\n      for (let col = 0; col < NUMBER_OF_COLS; col++) {\n        currentRow.push(this.createNode(col, row));\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  };\n  createNode = (col, row) => {\n    return {\n      isVisited: false,\n      col,\n      row,\n      isStart: row === START_NODE_ROW && col === START_NODE_COL,\n      isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n      distance: Infinity,\n      isWall: false,\n      previousNode: null,\n      isBomb: false\n    };\n  };\n\n  animateDijsktra = (\n    visitedNodesInOrder,\n    nodesInShortestPathOrder,\n    bomb,\n    nodesInShortestPathOrderWithBomb\n  ) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          if (!bomb) {\n            //no bomb\n            this.animateShortestPath(nodesInShortestPathOrder);\n          } else {\n            //bomb is present\n            this.animateShortestPath(nodesInShortestPathOrderWithBomb);\n            // return;\n          }\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        //if statement to avoid coloring of start and finish node\n        if (!(node.isStart || node.isFinish || node.isBomb)) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-visited\";\n        }\n      }, 10 * i);\n    }\n  };\n  //remove the arrow classname and calling this function in clearPath and clearBoard functions so that arrow are removed after visualization\n  removeArrowClass = () => {\n    const { grid } = this.state;\n    for (const row of grid) {\n      for (const node of row) {\n        const element = document.getElementById(`node-${node.row}-${node.col}`);\n        element.classList.remove(\"node-right-arrow\");\n        element.classList.remove(\"node-left-arrow\");\n        element.classList.remove(\"node-up-arrow\");\n        element.classList.remove(\"node-down-arrow\");\n      }\n    }\n  };\n  determineImage = (currentNode, previousNode) => {\n    const element = document.getElementById(\n      `node-${currentNode.row}-${currentNode.col}`\n    );\n    if (currentNode.col > previousNode.col) {\n      //moving right\n      element.className = \"node node-shortest-path node-right-arrow\";\n    } else if (currentNode.row < previousNode.row) {\n      //moving up\n      element.className = \"node node-shortest-path node-up-arrow\";\n    } else if (currentNode.col < previousNode.col) {\n      // moving left\n      element.className = \"node node-shortest-path node-left-arrow\";\n    } else if (currentNode.row > previousNode.row) {\n      //moving down\n      element.className = \"node node-shortest-path node-down-arrow\";\n    }\n  };\n  //this function adds the correct positioned arrow before the finish node as determineImage wasn't getting it correctly\n  arrowForSecondLastNode = (node, previousNode) => {\n    //two if conditions to escape the bug when no path to bombNode is found\n    if (previousNode === undefined) return;\n    if (node === undefined) return;\n    const element = document.getElementById(\n      `node-${previousNode.row}-${previousNode.col}`\n    );\n    if (node.col > previousNode.col) {\n      //finish node is right\n      element.className = \"node node-shortest-path node-right-arrow\";\n    } else if (node.row > previousNode.row) {\n      //finish node is below\n      element.className = \"node node-shortest-path node-down-arrow\";\n    } else if (node.row < previousNode.row) {\n      //finish node is above\n      element.className = \"node node-shortest-path node-up-arrow\";\n    } else if (node.col < previousNode.col) {\n      //finish node is left\n      element.className = \"node node-shortest-path node-left-arrow\";\n    }\n  };\n  animateShortestPath = nodesInShortestPathOrder => {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        const previousNode = nodesInShortestPathOrder[i - 1];\n        if (!(node.isStart || node.isFinish || node.isBomb)) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-shortest-path\";\n          //setting the arrow image\n          this.determineImage(node, previousNode);\n          //first we are setting the image of the current travelling node and then removing the previous one's image(if set) simultaneously to make it look like a moving arrow\n          //resetting the arrow image of previous node (so that it looks like a travelling arrow)\n          if (\n            !(\n              previousNode.isStart ||\n              previousNode.isFinish ||\n              previousNode.isBomb\n            )\n          ) {\n            document.getElementById(\n              `node-${previousNode.row}-${previousNode.col}`\n            ).style.backgroundImage = \"none\";\n          }\n        }\n        //this if block is for direction arrow of node just before finish node\n        if (node.isBomb) {\n          // this.determineImage(node, previousNode);\n          this.arrowForSecondLastNode(node, previousNode);\n        }\n        //this if block is for direction arrow of node just before finish node\n        if (node.isFinish) {\n          // this.determineImage(node, previousNode);\n          this.arrowForSecondLastNode(node, previousNode);\n        }\n        if (i === nodesInShortestPathOrder.length - 1) {\n          this.reEnableButtons();\n          this.enableGrid();\n        }\n      }, 50 * i);\n    }\n  };\n\n  animateDijsktraWithBomb = (\n    newVisitedNodesInOrder,\n    newNodesInShortestPathOrder0,\n    newStart,\n    newFinish\n  ) => {\n    for (let i = 0; i <= newVisitedNodesInOrder.length; i++) {\n      if (i === newVisitedNodesInOrder.length) {\n        setTimeout(() => {\n          const { grid } = this.state;\n          const visitedNodesInOrder = dijkstra(grid, newStart, newFinish);\n          const nodesInShortestPathOrder1 = getNodesInShortestPathOrder(\n            newFinish\n          );\n          const nodesInShortestPathOrder = [\n            ...newNodesInShortestPathOrder0,\n            ...nodesInShortestPathOrder1\n          ];\n          this.animateDijsktra(\n            visitedNodesInOrder,\n            nodesInShortestPathOrder1,\n            true,\n            nodesInShortestPathOrder\n          );\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = newVisitedNodesInOrder[i];\n        //if statement to avoid coloring of start and finish node\n        if (!(node.isStart || node.isFinish || node.isBomb)) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-bomb-visited\";\n        }\n      }, 10 * i);\n    }\n  };\n\n  visualizeDijkstra = () => {\n    centerText =\n      \"Dijkstra’s algorithm finds a shortest path tree from a single source node, by building a set of nodes that have minimum distance from the source. Dijkstra's algorithm guarantees shortest path.\";\n    //just to make sure that when visualize dijkstra button is clicked path is cleared so that in case we move the start Node without clearing the board algorithm starts from a new startPoint\n    //*if we don't clearPath dijkstra algorithm will start from the node whose distance is minimum and in the algorithms we have set the distance of startNode as 0(initially), so when we don't call clearPath function(in which we reset all the distance back to Infinity), and move the startNode to a new Point,visualization starts from the previous node only.\n    this.clearPath();\n    this.disableButtons();\n    this.disableGrid();\n    const { grid } = this.state;\n    let bombIsPresent = false;\n    if (bombNode.status) {\n      bombIsPresent = true;\n    }\n    const finish = grid[finishNode.row][finishNode.col];\n    if (!bombIsPresent) {\n      const start = grid[startNode.row][startNode.col];\n      const visitedNodesInOrder = dijkstra(grid, start, finish);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finish);\n      this.animateDijsktra(\n        visitedNodesInOrder,\n        nodesInShortestPathOrder,\n        false,\n        null\n      );\n    } else {\n      const bombNode1 = grid[bombNode.row][bombNode.col];\n      const start = grid[startNode.row][startNode.col];\n      const visitedNodesInOrder = dijkstra(grid, start, bombNode1);\n\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(bombNode1);\n      this.animateDijsktraWithBomb(\n        visitedNodesInOrder,\n        nodesInShortestPathOrder,\n        bombNode1,\n        finish\n      );\n    }\n  };\n  clearBoard = () => {\n    this.removeArrowClass();\n    this.removeBomb();\n    const { grid } = this.state;\n    const newGrid = grid.slice();\n    for (let i = 0; i < newGrid.length; i++) {\n      for (let j = 0; j < newGrid[i].length; j++) {\n        const element = document.getElementById(`node-${i}-${j}`);\n        element.classList.remove(\"node-visited\");\n        element.classList.remove(\"node-shortest-path\");\n        element.classList.remove(\"node-bomb-visited\");\n        //clearing class node-wall is optional(working fine otherwise also)\n        element.classList.remove(\"node-wall\");\n        newGrid[i][j].isVisited = false;\n        newGrid[i][j].distance = Infinity;\n        newGrid[i][j].isWall = false;\n        newGrid[i][j].previousNode = null;\n      }\n    }\n    this.setState({ grid: newGrid });\n  };\n  clearPath = () => {\n    this.removeArrowClass();\n    const { grid } = this.state;\n    const newGrid = grid.slice();\n    // console.log(newGrid[startNode.row][startNode.col]);\n    for (let i = 0; i < newGrid.length; i++) {\n      for (let j = 0; j < newGrid[i].length; j++) {\n        // console.log(newGrid[i][j]);\n        const element = document.getElementById(`node-${i}-${j}`);\n        element.classList.remove(\"node-visited\");\n        element.classList.remove(\"node-shortest-path\");\n        element.classList.remove(\"node-bomb-visited\");\n        newGrid[i][j].isVisited = false;\n        newGrid[i][j].distance = Infinity;\n        newGrid[i][j].previousNode = null;\n      }\n    }\n    this.setState({ grid: newGrid });\n  };\n  animateAstar = (\n    visitedNodesInOrder,\n    nodesInShortestPathOrder,\n    bomb,\n    nodesInShortestPathOrderWithBomb\n  ) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          if (!bomb) {\n            //no bomb\n            this.animateShortestPath(nodesInShortestPathOrder);\n          } else {\n            this.animateShortestPath(nodesInShortestPathOrderWithBomb);\n          }\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        //if statement to avoid coloring of start and finish node\n        if (!(node.isStart || node.isFinish || node.isBomb)) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-visited\";\n        }\n      }, 10 * i);\n    }\n  };\n  animateAstarWithBomb = (\n    newVisitedNodesInOrder,\n    newNodesInShortestPathOrder0,\n    newStart,\n    newFinish\n  ) => {\n    for (let i = 0; i <= newVisitedNodesInOrder.length; i++) {\n      if (i === newVisitedNodesInOrder.length) {\n        setTimeout(() => {\n          const { grid } = this.state;\n          const visitedNodesInOrder = astar(grid, newStart, newFinish);\n          const nodesInShortestPathOrder1 = getNodesInShortestPathOrderAstar(\n            newFinish\n          );\n          const nodesInShortestPathOrder = [\n            ...newNodesInShortestPathOrder0,\n            ...nodesInShortestPathOrder1\n          ];\n          this.animateAstar(\n            visitedNodesInOrder,\n            nodesInShortestPathOrder1,\n            true,\n            nodesInShortestPathOrder\n          );\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = newVisitedNodesInOrder[i];\n        //if statement to avoid coloring of start and finish node\n        if (!(node.isStart || node.isFinish || node.isBomb)) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-bomb-visited\";\n        }\n      }, 10 * i);\n    }\n  };\n  visualizeAstar = () => {\n    //disabling all buttons while visualization\n    centerText =\n      \"A* algorithm calculates heuristic distance(distance from the end node) which guides it towards the target node faster. A* algorithm guarantees shortest path..\";\n    this.disableButtons();\n    this.disableGrid();\n    this.clearPath();\n    const { grid } = this.state;\n    let bombIsPresent = false;\n    if (bombNode.status) {\n      bombIsPresent = true;\n    }\n    const start = grid[startNode.row][startNode.col];\n    const finish = grid[finishNode.row][finishNode.col];\n    if (!bombIsPresent) {\n      const visitedNodesInOrder = astar(grid, start, finish);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderAstar(finish);\n      this.animateAstar(\n        visitedNodesInOrder,\n        nodesInShortestPathOrder,\n        false,\n        null\n      );\n    } else {\n      const bombNode1 = grid[bombNode.row][bombNode.col];\n      const visitedNodesInOrder = astar(grid, start, bombNode1);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderAstar(\n        bombNode1\n      );\n      this.animateAstarWithBomb(\n        visitedNodesInOrder,\n        nodesInShortestPathOrder,\n        bombNode1,\n        finish\n      );\n    }\n  };\n  addBomb = () => {\n    this.clearPath();\n    centerText =\n      \"When bomb is active the algorithm will first try to find the shortest path to bomb to deactivate it and then will reach the finish node ..\";\n    const { grid } = this.state;\n    for (const row of grid) {\n      for (const node of row) {\n        if (node.row === bombNode.row && node.col === bombNode.col) {\n          node.isWall = false;\n          node.isBomb = true;\n        } else {\n          // node.bombNode = false;\n          // continue;\n        }\n      }\n    }\n    bombNode.status = true;\n    document.getElementById(`node-${bombNode.row}-${bombNode.col}`).className =\n      \"node node-bomb\";\n    this.setState({ grid });\n    document.getElementById(\"add-bomb-button\").disabled = true;\n  };\n  removeBomb = () => {\n    document.getElementById(\"add-bomb-button\").disabled = false;\n\n    centerText =\n      \"Click and drag mouse on the grid to draw obstacles(or select from different mazes), then click on the algorithm to find the shortest path ;) (try adding a bomb also...)\";\n    // bomb = false;\n    const { grid } = this.state;\n    const element = document.getElementById(\n      `node-${bombNode.row}-${bombNode.col}`\n    );\n    element.classList.remove(\"node-bomb\");\n    for (const row of grid) {\n      for (const node of row) {\n        node.isBomb = false;\n      }\n    }\n    bombNode.status = false;\n    this.setState({ grid });\n  };\n  genRandomNumber = () => {\n    return Math.floor(Math.random() * (NUMBER_OF_COLS * NUMBER_OF_ROWS));\n  };\n  resetNodeWalls = () => {\n    const { grid } = this.state;\n    const newGrid = grid.slice();\n    for (const row of newGrid) {\n      for (const node of row) {\n        node.isWall = false;\n      }\n    }\n    this.setState({ grid: newGrid });\n  };\n  genRandomWalls = () => {\n    this.clearPath();\n    this.resetNodeWalls();\n    const { grid } = this.state;\n    const newGrid = grid.slice();\n    let nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        if (\n          !(\n            (node.row === bombNode.row && node.col === bombNode.col) ||\n            (node.row === startNode.row && node.col === startNode.col) ||\n            (node.row === finishNode.row && node.col === finishNode.col)\n          )\n        ) {\n          nodes.push(node);\n        }\n      }\n    }\n    let numberOfPlainNodes = nodes.length;\n    let x = Math.floor((40 / 100) * numberOfPlainNodes),\n      random = this.genRandomNumber();\n    //some kind of error with genRandomWall function, to ignore it following two if statements are there, check later if problem persists \"cannot read property nodes[random].isWall of unknown\"\n    while (x) {\n      if (nodes[random] === undefined) return;\n      if (nodes[random].isWall === undefined) return;\n      nodes[random].isWall = !nodes[random].isWall;\n      x -= 1;\n\n      random = this.genRandomNumber();\n    }\n    this.setState({ grid: newGrid });\n  };\n  visualizeRecursiveDivision = () => {\n    this.clearBoard();\n    this.disableButtons();\n    this.disableGrid();\n    const { grid } = this.state;\n    const nodes = recursiveDivision(grid, NUMBER_OF_ROWS, NUMBER_OF_COLS);\n    for (let k = 0; k < nodes.length; k++) {\n      //our nodes array will always more likely be greater than the actual number of nodes on the grid (as the way we are filling the array (setting the pattern number of time,see while loop in corresponding maze algorithm), and then pruning our nodes array till it reaches undefined i.e to the size of the number of nodes in the grid)\n      if (nodes[k] === undefined) {\n        return;\n      }\n\n      setTimeout(() => {\n        if (!(nodes[k].isStart || nodes[k].isFinish || nodes[k].isBomb)) {\n          nodes[k].isWall = true;\n          const element = document.getElementById(\n            `node-${nodes[k].row}-${nodes[k].col}`\n          );\n          element.className = \"node node-wall\";\n        }\n        //we would'nt have reached nodes[k]===undefined as we are returning from that point so we are checking in advance (also so that disabling persists while walls are being drawn)\n        if (nodes[k + 1] === undefined) {\n          this.reEnableButtons();\n          this.enableGrid();\n        }\n      }, k * 10);\n    }\n  };\n  visualizeStaircase = () => {\n    this.clearBoard();\n    this.disableButtons();\n    this.disableGrid();\n    const { grid } = this.state;\n    const nodes = staircaseMaze(grid, NUMBER_OF_ROWS, NUMBER_OF_COLS);\n    for (let k = 0; k < nodes.length; k++) {\n      if (nodes[k] === undefined) {\n        return;\n      }\n      setTimeout(() => {\n        if (!(nodes[k].isStart || nodes[k].isFinish || nodes[k].isBomb)) {\n          nodes[k].isWall = true;\n          const element = document.getElementById(\n            `node-${nodes[k].row}-${nodes[k].col}`\n          );\n          element.className = \"node node-wall\";\n        }\n        if (nodes[k + 1] === undefined) {\n          this.reEnableButtons();\n          this.enableGrid();\n        }\n      }, k * 10);\n    }\n  };\n  visualizeMazeThree = () => {\n    this.clearBoard();\n    this.disableButtons();\n    this.disableGrid();\n    const { grid } = this.state;\n    const nodes = mazeThree(grid, NUMBER_OF_ROWS, NUMBER_OF_COLS);\n    for (let k = 0; k < nodes.length; k++) {\n      if (nodes[k] === undefined) {\n        return;\n      }\n      setTimeout(() => {\n        if (!(nodes[k].isStart || nodes[k].isFinish || nodes[k].isBomb)) {\n          nodes[k].isWall = true;\n          const element = document.getElementById(\n            `node-${nodes[k].row}-${nodes[k].col}`\n          );\n          element.className = \"node node-wall\";\n        }\n        if (nodes[k + 1] === undefined) {\n          this.reEnableButtons();\n          this.enableGrid();\n        }\n      }, k * 10);\n    }\n  };\n  visualizeMazeFour = () => {\n    this.clearBoard();\n    this.disableButtons();\n    this.disableGrid();\n    const { grid } = this.state;\n    const nodes = mazeFour(grid, NUMBER_OF_ROWS, NUMBER_OF_COLS);\n    for (let k = 0; k < nodes.length; k++) {\n      if (nodes[k] === undefined) {\n        return;\n      }\n      setTimeout(() => {\n        if (!(nodes[k].isStart || nodes[k].isFinish || nodes[k].isBomb)) {\n          nodes[k].isWall = true;\n          const element = document.getElementById(\n            `node-${nodes[k].row}-${nodes[k].col}`\n          );\n          element.className = \"node node-wall\";\n        }\n        if (nodes[k + 1] === undefined) {\n          this.reEnableButtons();\n          this.enableGrid();\n        }\n      }, k * 10);\n    }\n  };\n  disableGrid = () => {\n    const { grid } = this.state;\n    for (const row of grid) {\n      for (const node of row) {\n        const element = document.getElementById(`node-${node.row}-${node.col}`);\n        element.style.pointerEvents = \"none\";\n      }\n    }\n  };\n  enableGrid = () => {\n    const { grid } = this.state;\n    for (const row of grid) {\n      for (const node of row) {\n        const element = document.getElementById(`node-${node.row}-${node.col}`);\n        element.style.pointerEvents = \"auto\";\n      }\n    }\n  };\n  disableButtons = () => {\n    const buttons = document.getElementsByClassName(\"btn\");\n    for (let k = 0; k < buttons.length; k++) {\n      buttons[k].disabled = true;\n    }\n  };\n  reEnableButtons = () => {\n    const buttons = document.getElementsByClassName(\"btn\");\n\n    for (let k = 0; k < buttons.length; k++) {\n      buttons[k].disabled = false;\n    }\n    //keeping addBomb button disabled if it is present on the grid\n    if (bombNode.status) {\n      document.getElementById(\"add-bomb-button\").disabled = true;\n    }\n  };\n  render() {\n    const myStyle = {\n      color: \"black\",\n      backgroundColor: \"ghostwhite\",\n      padding: \"0.5px\",\n      fontFamily: \"Arial\",\n      // position: \"absolute\",\n      textContent: \"center\",\n      display: \"inline-block\",\n      marginBottom: \"0px\",\n      fontStyle: \"italic\"\n    };\n\n    return (\n      <div>\n        <div className=\"App\" id=\"mainContent\">\n          <div id=\"navBarContent\">\n            <NavBar\n              visualizeDijkstra={() => this.visualizeDijkstra()}\n              visualizeAstar={() => this.visualizeAstar()}\n              clearBoard={() => this.clearBoard()}\n              clearPath={() => this.clearPath()}\n              addBomb={() => this.addBomb()}\n              removeBomb={() => this.removeBomb()}\n              genRandomWalls={() => this.genRandomWalls()}\n              visualizeRecursiveDivision={() =>\n                this.visualizeRecursiveDivision()\n              }\n              visualizeStaircase={() => this.visualizeStaircase()}\n              visualizeMazeThree={() => this.visualizeMazeThree()}\n              visualizeMazeFour={() => this.visualizeMazeFour()}\n            />\n          </div>\n          <div id=\"textContent\">\n            <NavLink activeClassName=\"active\" to=\"/demo\">\n              <button\n                className=\"btn btn-light btn-lg\"\n                style={{ float: \"left\" }}\n                id=\"demo-button\"\n              >\n                Quick Demo\n              </button>\n            </NavLink>\n            <div style={myStyle}>\n              <div id=\"alignHelperDiv\">\n                <div id=\"wallNodeImage\"> </div> Wall Node\n              </div>\n              <div id=\"alignHelperDiv\">\n                <div id=\"emptyNodeImage\"> </div> Unvisited Node\n              </div>\n              <div id=\"alignHelperDiv\">\n                <div id=\"visitedNodeImage1\"> </div>\n              </div>\n              <div id=\"alignHelperDiv\">\n                <div id=\"visitedNodeImage2\"> </div> Visited Nodes\n              </div>\n              <div id=\"alignHelperDiv\">\n                <div id=\"startNodeImage\"> </div> Start Node\n              </div>\n              <div id=\"alignHelperDiv\">\n                <div id=\"finishNodeImage\"> </div> Finish Node\n              </div>\n              <div id=\"alignHelperDiv\">\n                <div id=\"bombNodeImage\"> </div> Bomb Node\n              </div>\n              <div id=\"alignHelperDiv\">\n                <div id=\"shortestPathImage\"> </div>Shortest Path Node\n              </div>\n            </div>\n            <strong style={myStyle}>{centerText}</strong>\n          </div>\n          <div id=\"gridContent\">\n            <PathfindingVisualizer\n              grid={this.state.grid}\n              mouseIsPressed={this.state.mouseIsPressed}\n              handleMouseUp={(row, col) => this.handleMouseUp(row, col)}\n              handleMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\n              handleMouseDown={(row, col) => this.handleMouseDown(row, col)}\n            />\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import React, { Component } from \"react\";\n\nexport class NotFound extends Component {\n  render() {\n    return (\n      <div>\n        <h1>Not Found</h1>\n      </div>\n    );\n  }\n}\n\nexport default NotFound;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport {\n  Route,\n  NavLink,\n  // BrowserRouter as Router,\n  HashRouter as Router,\n  Switch\n} from \"react-router-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport Demo from \"./animations/Demo\";\nimport NotFound from \"./animations/NotFound\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport \"../node_modules/bootstrap/dist/css/bootstrap.min.css\";\n\n// ReactDOM.render(<Router />, document.getElementById(\"root\"));\n// ReactDOM.render(<App />, document.getElementById(\"root\"));\n\nconst routing = (\n  <Router>\n    <div>\n      {/* <ul>\n        <li>\n          <NavLink exact activeClassName=\"active\" to=\"/\">\n            app\n          </NavLink>\n        </li>\n        <li>\n          <NavLink activeClassName=\"active\" to=\"/demo\">\n            Demo\n          </NavLink>\n        </li>\n      </ul> */}\n      <Switch>\n        <Route exact path=\"/\" component={App} />\n        <Route path=\"/demo\" component={Demo} />\n        <Route\n          path=\"/article\"\n          component={() => {\n            window.location.href = \"https://en.wikipedia.org/wiki/Pathfinding\";\n            return null;\n          }}\n        />\n        <Route component={NotFound} />\n      </Switch>\n      {/* <hr /> */}\n    </div>\n  </Router>\n);\n\nReactDOM.render(routing, document.getElementById(\"root\"));\n//Switch component only render the components when path matches otherwise it fallsback to the component \"NotFound\"\n//Refer to the link to understand the routing part in case of doubt\n//https://codeburst.io/getting-started-with-react-router-5c978f70df91\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}